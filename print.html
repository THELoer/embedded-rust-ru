<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Embedded Rust Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Embedded Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-embedded/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<p>Добро пожаловать в Книгу по Embedded Rust: вводную книгу об использовании языка программирования Rust на "Bare Metal" встраиваемых системах, таких как микроконтроллеры.</p>
<h2 id="Для-кого-предназначен-embedded-rust"><a class="header" href="#Для-кого-предназначен-embedded-rust">Для кого предназначен Embedded Rust</a></h2>
<p>Embedded Rust предназначен для всех, кто хочет заниматься встраиваемым программированием, используя преимущества концепций более высокого уровня и гарантий безопасности, предоставляемых языком Rust.
(См. также <a href="https://doc.rust-lang.org/book/ch00-00-introduction.html">Для кого предназначен Rust</a>)</p>
<h2 id="Область-применения"><a class="header" href="#Область-применения">Область применения</a></h2>
<p>Цели этой книги:</p>
<ul>
<li>
<p>Помочь разработчикам быстро освоить разработку на embedded Rust. Т.е. как настроить среду разработки.</p>
</li>
<li>
<p>Поделиться <em>текущими</em> лучшими практиками использования Rust для разработки встраиваемых систем. Т.е. как лучше использовать функции языка Rust для написания более правильного ПО для встраиваемых систем.</p>
</li>
<li>
<p>Служить кулинарной книгой в некоторых случаях. Например, как смешать C и Rust в одном проекте?</p>
</li>
</ul>
<p>Эта книга старается быть как можно более общей, но для облегчения как для читателей, так и для авторов она использует архитектуру ARM Cortex-M во всех примерах. Однако книга не предполагает, что читатель знаком с этой конкретной архитектурой, и объясняет детали, специфичные для этой архитектуры, где это необходимо.</p>
<h2 id="Для-кого-эта-книга"><a class="header" href="#Для-кого-эта-книга">Для кого эта книга</a></h2>
<p>Эта книга ориентирована на людей с опытом либо в embedded-разработке, либо в Rust, однако мы считаем, что каждый, интересующийся embedded-программированием на Rust, может извлечь из этой книги пользу. Для тех, у кого нет предварительных знаний, мы предлагаем прочитать раздел "Предположения и предпосылки" и наверстать упущенные знания, чтобы получить больше от книги и улучшить опыт чтения. Вы можете посмотреть раздел "Другие ресурсы", чтобы найти материалы по темам, которые вы хотите наверстать.</p>
<h3 id="Предположения-и-предпосылки"><a class="header" href="#Предположения-и-предпосылки">Предположения и предпосылки</a></h3>
<ul>
<li>Вы комфортно используете язык программирования Rust и написали, запустили и отлаживали приложения на Rust в десктопной среде. Вы также должны быть знакомы с идиомами [издания 2018 года], поскольку эта книга ориентирована на Rust 2018.</li>
</ul>
<ul>
<li>Вы комфортно разрабатываете и отлаживаете встраиваемые системы на другом языке, таком как C, C++ или Ada, и знакомы с концепциями, такими как:
<ul>
<li>Кросс-компиляция</li>
<li>Периферийные устройства, отображенные в память</li>
<li>Прерывания</li>
<li>Общие интерфейсы, такие как I2C, SPI, Serial и т.д.</li>
</ul>
</li>
</ul>
<h3 id="Другие-ресурсы"><a class="header" href="#Другие-ресурсы">Другие ресурсы</a></h3>
<p>Если вы не знакомы с чем-либо упомянутым выше или хотите больше информации по конкретной теме, упомянутой в этой книге, вы можете найти некоторые из этих ресурсов полезными.</p>
<div class="table-wrapper"><table><thead><tr><th>Тема</th><th>Ресурс</th><th>Описание</th></tr></thead><tbody>
<tr><td>Rust</td><td><a href="https://doc.rust-lang.org/book/">Книга по Rust</a></td><td>Если вы еще не комфортно владеете Rust, мы настоятельно рекомендуем прочитать эту книгу.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/discovery/">Книга Discovery</a></td><td>Если вы никогда не занимались embedded-программированием, эта книга может быть лучшим стартом</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org">Полка книг по Embedded Rust</a></td><td>Здесь вы можете найти несколько других ресурсов, предоставленных рабочей группой Embedded Rust.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/embedonomicon/">Embedonomicon</a></td><td>Детали embedded-программирования на Rust.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/faq.html">FAQ по embedded</a></td><td>Часто задаваемые вопросы по Rust в embedded.</td></tr>
<tr><td>Встраиваемое программирование</td><td><a href="https://www.coursera.org/learn/introduction-embedded-systems">Курс на Coursera</a></td><td>Бесплатный курс на Coursera по встраиваемым системам.</td></tr>
<tr><td>Встраиваемое программирование</td><td><a href="https://www.edx.org/course/embedded-systems-shape-world-utaustinx-ut-6-02x">Курс на edX</a></td><td>Бесплатный курс на edX по встраиваемым системам.</td></tr>
<tr><td>Прерывания</td><td><a href="https://en.wikipedia.org/wiki/Interrupt">Прерывание</a></td><td>-</td></tr>
<tr><td>Отображение ввода/вывода в память/Периферийные устройства</td><td><a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Отображение ввода/вывода в память</a></td><td>-</td></tr>
<tr><td>SPI, UART, RS232, USB, I2C, TTL</td><td><a href="https://electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-are-all-of-these-and-how-do-th">Stack Exchange о SPI, UART и других интерфейсах</a></td><td>-</td></tr>
</tbody></table>
</div>
<h3 id="Переводы"><a class="header" href="#Переводы">Переводы</a></h3>
<p>Эта книга переведена щедрыми добровольцами. Если вы хотите, чтобы ваш перевод был перечислен здесь, пожалуйста, откройте PR, чтобы добавить его.</p>
<ul>
<li>
<p><a href="https://tomoyuki-nakabayashi.github.io/book/">Японский</a>
(<a href="https://github.com/tomoyuki-nakabayashi/book">репозиторий</a>)</p>
</li>
<li>
<p><a href="https://xxchang.github.io/book/">Китайский</a>
(<a href="https://github.com/XxChang/book">репозиторий</a>)</p>
</li>
</ul>
<h2 id="Как-использовать-эту-книгу"><a class="header" href="#Как-использовать-эту-книгу">Как использовать эту книгу</a></h2>
<p>Эта книга в целом предполагает, что вы читаете ее от начала до конца. Более поздние главы строятся на концепциях из ранних глав, и ранние главы могут не углубляться в детали темы, возвращаясь к ней в более поздней главе.</p>
<p>Эта книга будет использовать плату разработки <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> от STMicroelectronics для большинства примеров. Эта плата основана на архитектуре ARM Cortex-M, и хотя базовая функциональность одинакова для большинства CPU на этой архитектуре, периферийные устройства и другие детали реализации микроконтроллеров отличаются между разными производителями и даже между семьями микроконтроллеров от одного производителя.</p>
<p>По этой причине мы рекомендуем приобрести плату разработки <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> для следования примерам в этой книге.</p>
<h2 id="Вклад-в-эту-книгу"><a class="header" href="#Вклад-в-эту-книгу">Вклад в эту книгу</a></h2>
<p>Работа над этой книгой координируется в <a href="https://github.com/rust-embedded/book">этом репозитории</a> и в основном разрабатывается <a href="https://github.com/rust-embedded/wg#the-resources-team">командой ресурсов</a>.</p>
<p>Если у вас проблемы со следующими инструкциями в этой книге или вы находите, что какой-то раздел книги недостаточно ясен или трудно следовать, то это ошибка, и ее следует сообщить в <a href="https://github.com/rust-embedded/book/issues/">отслеживателе задач</a> этой книги.</p>
<p>Пулл-реквесты, исправляющие опечатки и добавляющие новый контент, очень приветствуются!</p>
<h2 id="Переиспользование-этого-материала"><a class="header" href="#Переиспользование-этого-материала">Переиспользование этого материала</a></h2>
<p>Эта книга распространяется под следующими лицензиями:</p>
<ul>
<li>Примеры кода и отдельные проекты Cargo, содержащиеся в этой книге, лицензированы на условиях как [лицензии MIT], так и [лицензии Apache v2.0].</li>
<li>Проза, изображения и диаграммы, содержащиеся в этой книге, лицензированы на условиях лицензии Creative Commons <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a>.</li>
</ul>
<p>Коротко: Если вы хотите использовать наш текст или изображения в своей работе, вам нужно:</p>
<ul>
<li>Дать соответствующую атрибуцию (т.е. упомянуть эту книгу на вашем слайде и предоставить ссылку на соответствующую страницу)</li>
<li>Предоставить ссылку на лицензию <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a></li>
<li>Указать, если вы изменили материал каким-либо образом, и сделать любые изменения в нашем материале доступными под той же лицензией</li>
</ul>
<p>Также, пожалуйста, дайте нам знать, если вы находите эту книгу полезной!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Знакомство-с-аппаратным-обеспечением"><a class="header" href="#Знакомство-с-аппаратным-обеспечением">Знакомство с аппаратным обеспечением</a></h1>
<p>Давайте познакомимся с аппаратным обеспечением, с которым мы будем работать.</p>
<h2 id="stm32f3discovery--f3"><a class="header" href="#stm32f3discovery--f3">STM32F3DISCOVERY ( "F3")</a></h2>
<p align="center">
<img title="F3" src="intro/../assets/f3.jpg">
</p>
<p>Что содержит эта плата?</p>
<ul>
<li>
<p>Микроконтроллер <a href="https://www.st.com/en/microcontrollers/stm32f303vc.html">STM32F303VCT6</a>. Этот микроконтроллер имеет</p>
<ul>
<li>
<p>Одноядерный процессор ARM Cortex-M4F с аппаратной поддержкой операций с плавающей запятой одинарной точности и максимальной тактовой частотой 72 МГц.</p>
</li>
<li>
<p>256 КБ "Flash" памяти. (1 КБ = 1024 байта)</p>
</li>
<li>
<p>48 КБ ОЗУ.</p>
</li>
<li>
<p>Разнообразные интегрированные периферийные устройства, такие как таймеры, I2C, SPI и USART.</p>
</li>
<li>
<p>Ввод/вывод общего назначения (GPIO) и другие типы пинов, доступные через две ряда заголовков вдоль края платы.</p>
</li>
<li>
<p>Интерфейс USB, доступный через порт USB с меткой "USB USER".</p>
</li>
</ul>
</li>
<li>
<p>Акцелерометр как часть чипа <a href="https://www.st.com/en/mems-and-sensors/lsm303dlhc.html">LSM303DLHC</a>.</p>
</li>
<li>
<p>Магнитометр как часть чипа <a href="https://www.st.com/en/mems-and-sensors/lsm303dlhc.html">LSM303DLHC</a>.</p>
</li>
<li>
<p>Гироскоп как часть чипа <a href="https://www.pololu.com/file/0J563/L3GD20.pdf">L3GD20</a>.</p>
</li>
<li>
<p>8 пользовательских светодиодов, расположенных в форме компаса.</p>
</li>
<li>
<p>Второй микроконтроллер: <a href="https://www.st.com/en/microcontrollers/stm32f103cb.html">STM32F103</a>. Этот микроконтроллер на самом деле является частью встроенного программатора/отладчика и подключен к порту USB с меткой "USB ST-LINK".</p>
</li>
</ul>
<p>Для более подробного списка функций и дальнейших спецификаций платы посмотрите на сайте <a href="https://www.st.com/en/evaluation-tools/stm32f3discovery.html">STMicroelectronics</a>.</p>
<p>Слово предосторожности: будьте осторожны, если хотите применять внешние сигналы к плате. Пины микроконтроллера STM32F303VCT6 принимают номинальное напряжение 3.3 вольта. Для дополнительной информации обратитесь к разделу <a href="https://www.st.com/resource/en/datasheet/stm32f303vc.pdf">6.2 Absolute maximum ratings в руководстве</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Окружение-rust-с-no_std"><a class="header" href="#Окружение-rust-с-no_std">Окружение Rust с <code>no_std</code></a></h1>
<p>Термин "встраиваемое программирование" используется для широкого спектра классов программирования.
От программирования 8-битных микроконтроллеров (например, <a href="https://www.st.com/resource/en/datasheet/st72325j6.pdf">ST72325xx</a>)
с всего несколькими КБ ОЗУ и ПЗУ до систем вроде Raspberry Pi
(<a href="https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications">Model B 3+</a>), которая имеет 32/64-битный 4-ядерный процессор Cortex-A53 с частотой 1.4 ГГц и 1 ГБ ОЗУ. Разные ограничения применяются при написании кода в зависимости от цели и случая использования.</p>
<p>Существуют два общих класса встраиваемого программирования:</p>
<h2 id="Хостинговые-окружения"><a class="header" href="#Хостинговые-окружения">Хостинговые окружения</a></h2>
<p>Такие окружения близки к обычному окружению ПК.
Это означает, что предоставляется системный интерфейс <a href="https://en.wikipedia.org/wiki/POSIX">например, POSIX</a>,
который дает примитивы для взаимодействия с различными системами, такими как файловые системы, сеть, управление памятью, потоки и т.д.
Стандартные библиотеки, в свою очередь, обычно зависят от этих примитивов для реализации своей функциональности.
Также может быть sysroot и ограничения на использование ОЗУ/ПЗУ, а также специальное оборудование или ввод/вывод. В целом это похоже на программирование в специальной среде ПК.</p>
<h2 id="Окружения-без-ОС-bare-metal"><a class="header" href="#Окружения-без-ОС-bare-metal">Окружения без ОС (Bare Metal)</a></h2>
<p>В окружении без ОС (bare metal) перед вашей программой не загружено никакого кода.
Без ПО, предоставляемого ОС, мы не можем загрузить стандартную библиотеку.
Вместо этого программа вместе с используемыми крейтами может использовать только аппаратное обеспечение (bare metal) для выполнения.
Чтобы предотвратить загрузку стандартной библиотеки Rust, используйте <code>no_std</code>.
Части стандартной библиотеки, не зависящие от платформы, доступны через <a href="https://doc.rust-lang.org/core/">libcore</a>.
libcore также исключает вещи, которые не всегда желательны в окружении встраиваемых систем.
Одна из них — распределитель памяти для динамического выделения памяти.
Если требуется это или другие функциональности, часто есть крейты, которые их предоставляют.</p>
<h3 id="runtime-libstd"><a class="header" href="#runtime-libstd">Runtime libstd</a></h3>
<p>Как упоминалось ранее, использование <a href="https://doc.rust-lang.org/std/">libstd</a> требует некоторой системной интеграции, но не только потому,
что <a href="https://doc.rust-lang.org/std/">libstd</a> просто предоставляет общий способ доступа к абстракциям ОС, она также предоставляет runtime.
Эта runtime, среди прочего, настраивает защиту от переполнения стека, обрабатывает аргументы командной строки
и порождает основной поток перед вызовом главной функции программы. Эта runtime также недоступна в окружении <code>no_std</code>.</p>
<h2 id="Итог"><a class="header" href="#Итог">Итог</a></h2>
<p><code>#![no_std]</code> — это атрибут на уровне крейта, указывающий, что крейт будет ссылаться на крейт core вместо std.
Крейт <a href="https://doc.rust-lang.org/core/">libcore</a>, в свою очередь, — это подмножество std, не зависящее от платформы,
которое не делает предположений о системе, на которой будет работать программа.
Таким образом, он предоставляет API для языковых примитивов, таких как числа с плавающей запятой, строки и слайсы, а также API, раскрывающие функции процессора,
такие как атомарные операции и инструкции SIMD. Однако он не предоставляет API для чего-либо, что включает интеграцию с платформой.
Благодаря этим свойствам код с no_std и <a href="https://doc.rust-lang.org/core/">libcore</a> может использоваться для любого вида
загрузочного (stage 0) кода, такого как загрузчики, прошивки или ядра.</p>
<h3 id="Обзор"><a class="header" href="#Обзор">Обзор</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Функция</th><th>no_std</th><th>std</th></tr></thead><tbody>
<tr><td>куча (динамическая память)</td><td>*</td><td>✓</td></tr>
<tr><td>коллекции (Vec, BTreeMap и т.д.)</td><td>**</td><td>✓</td></tr>
<tr><td>защита от переполнения стека</td><td>✘</td><td>✓</td></tr>
<tr><td>выполнение кода инициализации перед main</td><td>✘</td><td>✓</td></tr>
<tr><td>доступна libstd</td><td>✘</td><td>✓</td></tr>
<tr><td>доступна libcore</td><td>✓</td><td>✓</td></tr>
<tr><td>написание прошивки, ядра или кода загрузчика</td><td>✓</td><td>✘</td></tr>
</tbody></table>
</div>
<p>* Только если вы используете крейт <code>alloc</code> и подходящий распределитель, такой как <a href="https://github.com/rust-embedded/alloc-cortex-m">alloc-cortex-m</a>.</p>
<p>** Только если вы используете крейт <code>collections</code> и настраиваете глобальный распределитель по умолчанию.</p>
<p>** HashMap и HashSet недоступны из-за отсутствия безопасного генератора случайных чисел.</p>
<h2 id="См-также"><a class="header" href="#См-также">См. также</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md">RFC-1184</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Инструменты"><a class="header" href="#Инструменты">Инструменты</a></h1>
<p>Работа с микроконтроллерами включает использование нескольких различных инструментов, поскольку мы имеем дело с архитектурой, отличной от вашего ноутбука, и нам придется запускать и отлаживать программы на <em>удаленном</em> устройстве.</p>
<p>Мы будем использовать все перечисленные ниже инструменты. Любая недавняя версия должна работать, если не указана минимальная версия, но мы перечислили протестированные версии.</p>
<ul>
<li>Rust 1.31, 1.31-beta или более новая цепочка инструментов ПЛЮС поддержка компиляции для ARM Cortex-M.</li>
<li><a href="https://github.com/rust-embedded/cargo-binutils"><code>cargo-binutils</code></a> ~0.1.4</li>
<li><a href="https://www.qemu.org/"><code>qemu-system-arm</code></a>. Протестированные версии: 3.0.0</li>
<li>OpenOCD &gt;=0.8. Протестированные версии: v0.9.0 и v0.10.0</li>
<li>GDB с поддержкой ARM. Рекомендуется версия 7.12 или новее. Протестированные версии: 7.10, 7.11, 7.12 и 8.1</li>
<li><a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code></a> или <code>git</code>. Эти инструменты опциональны, но облегчат следование книге.</li>
</ul>
<p>Текст ниже объясняет, почему мы используем эти инструменты. Инструкции по установке можно найти на следующей странице.</p>
<h2 id="cargo-generate-ИЛИ-git"><a class="header" href="#cargo-generate-ИЛИ-git"><code>cargo-generate</code> ИЛИ <code>git</code></a></h2>
<p>Программы без ОС (bare metal) — это нестандартные (<code>no_std</code>) программы на Rust, требующие некоторых корректировок процесса линковки для правильной компоновки памяти. Это требует дополнительных файлов (таких как скрипты линковки) и настроек (таких как флаги линковки). Мы упаковали их для вас в шаблон, так что вам нужно только заполнить недостающую информацию (например, имя проекта и характеристики целевого оборудования).</p>
<p>Наш шаблон совместим с <code>cargo-generate</code>: подкомандой Cargo для создания новых проектов Cargo из шаблонов. Вы также можете скачать шаблон с помощью <code>git</code>, <code>curl</code>, <code>wget</code> или вашего веб-браузера.</p>
<h2 id="cargo-binutils"><a class="header" href="#cargo-binutils"><code>cargo-binutils</code></a></h2>
<p><code>cargo-binutils</code> — это коллекция подкоманд Cargo, облегчающих использование инструментов LLVM, поставляемых с цепочкой инструментов Rust. Эти инструменты включают версии LLVM <code>objdump</code>, <code>nm</code> и <code>size</code> и используются для инспекции бинарных файлов.</p>
<p>Преимущество использования этих инструментов перед GNU binutils заключается в том, что (a) установка инструментов LLVM — это одна команда (<code>rustup component add llvm-tools</code>) независимо от вашей ОС и (b) инструменты вроде <code>objdump</code> поддерживают все архитектуры, поддерживаемые <code>rustc</code> — от ARM до x86_64 — поскольку они оба используют один и тот же бэкенд LLVM.</p>
<h2 id="qemu-system-arm"><a class="header" href="#qemu-system-arm"><code>qemu-system-arm</code></a></h2>
<p>QEMU — это эмулятор. В данном случае мы используем вариант, который может полностью эмулировать системы ARM. Мы используем QEMU для запуска программ для встраиваемых систем на хосте. Благодаря этому вы можете следовать некоторым частям этой книги, даже если у вас нет оборудования!</p>
<h1 id="Инструменты-для-отладки-embedded-rust"><a class="header" href="#Инструменты-для-отладки-embedded-rust">Инструменты для отладки Embedded Rust</a></h1>
<h2 id="Обзор-1"><a class="header" href="#Обзор-1">Обзор</a></h2>
<p>Отладка встраиваемых систем в Rust требует специализированных инструментов, включая ПО для управления процессом отладки, отладчики для инспекции и управления выполнением программы, а также аппаратные пробники для взаимодействия между хостом и встраиваемым устройством. Этот документ описывает основные программные инструменты, такие как Probe-rs и OpenOCD, которые упрощают и поддерживают процесс отладки, а также известные отладчики, такие как GDB и расширение Probe-rs для Visual Studio Code. Кроме того, он охватывает ключевые аппаратные пробники, такие как Rusty-probe, ST-Link, J-Link и MCU-Link, которые необходимы для эффективной отладки и программирования встраиваемых устройств.</p>
<h2 id="ПО-управляющее-инструментами-отладки"><a class="header" href="#ПО-управляющее-инструментами-отладки">ПО, управляющее инструментами отладки</a></h2>
<h3 id="probe-rs"><a class="header" href="#probe-rs">Probe-rs</a></h3>
<p>Probe-rs — это современное ПО, ориентированное на Rust, предназначенное для работы с отладчиками во встраиваемых системах. В отличие от OpenOCD, Probe-rs разработан с учетом простоты и стремится уменьшить нагрузку на конфигурацию, часто встречающуюся в других решениях отладки. Он поддерживает различные пробники и цели, предоставляя высокоуровневый интерфейс для взаимодействия со встраиваемыми системами. Probe-rs позволяет разработчикам устанавливать точки останова, шагать по коду и исследовать состояние памяти и регистров процессора. Он интегрируется с популярными IDE, такими как Visual Studio Code, и поддерживает функции, специфичные для Rust, такие как красивая печать и детализированные сообщения об ошибках.</p>
<h3 id="openocd"><a class="header" href="#openocd">OpenOCD</a></h3>
<p>OpenOCD (Open On-Chip Debugger) — это открытое ПО для отладки и программирования встраиваемых систем. Оно поддерживает широкий спектр аппаратных пробников и микроконтроллеров, позволяя разработчикам взаимодействовать с целевыми устройствами через интерфейсы вроде JTAG или SWD. OpenOCD служит сервером отладки, который может подключаться к отладчикам вроде GDB, предоставляя низкоуровневый доступ к регистрам, памяти и периферийным устройствам микроконтроллера. Он высоко конфигурируем и используется в различных окружениях разработки для встраиваемых систем.</p>
<h2 id="Отладчики"><a class="header" href="#Отладчики">Отладчики</a></h2>
<p>Отладчики — это инструменты, позволяющие разработчикам проверять состояние программ во время выполнения или после сбоя. Они предоставляют функциональности, такие как установка точек останова, шагание по коду строка за строкой и исследование значений переменных и состояний памяти. Отладчики необходимы для тщательной разработки и обслуживания ПО, позволяя разработчикам убедиться, что их код ведет себя как ожидается в различных условиях.</p>
<p>Отладчики знают, как:</p>
<ul>
<li>Взаимодействовать с регистрами, отображенными в память.</li>
<li>Устанавливать точки останова/наблюдения.</li>
<li>Читать и писать в регистры, отображенные в память.</li>
<li>Обнаруживать, когда микроконтроллер остановлен для события отладки.</li>
<li>Продолжать выполнение микроконтроллера после события отладки.</li>
<li>Стирать и записывать в FLASH микроконтроллера.</li>
</ul>
<h3 id="Расширение-probe-rs-для-visual-studio-code"><a class="header" href="#Расширение-probe-rs-для-visual-studio-code">Расширение Probe-rs для Visual Studio Code</a></h3>
<p>Probe-rs имеет расширение для Visual Studio Code, предоставляющее seamless опыт отладки без обширной настройки. Через это соединение разработчики могут использовать функции, специфичные для Rust, такие как красивая печать и детализированные сообщения об ошибках, обеспечивая, что процесс отладки соответствует экосистеме Rust.</p>
<h3 id="gdb-gnu-debugger"><a class="header" href="#gdb-gnu-debugger">GDB (GNU Debugger)</a></h3>
<p>GDB — это универсальный инструмент отладки, позволяющий разработчикам проверять состояние программ во время выполнения или после сбоя. Для embedded Rust GDB подключается к целевой системе через OpenOCD или другие серверы отладки для взаимодействия с кодом встраиваемой системы. GDB высоко конфигурируем и поддерживает функции вроде удаленной отладки, инспекции переменных и условных точек останова. Он может использоваться на различных платформах и имеет обширную поддержку нужд отладки, специфичных для Rust, таких как красивая печать и интеграция с IDE.</p>
<h2 id="Пробники"><a class="header" href="#Пробники">Пробники</a></h2>
<p>Аппаратный пробник — это устройство, используемое в разработке и отладке встраиваемых систем для облегчения коммуникации между хост-компьютером и целевым встраиваемым устройством. Он обычно поддерживает протоколы вроде JTAG или SWD, позволяя программировать, отлаживать и анализировать микроконтроллер или микропроцессор на встраиваемой системе. Аппаратные пробники критичны для разработчиков, чтобы устанавливать точки останова, шагать по коду и инспектировать память и регистры процессора, эффективно позволяя диагностировать и исправлять проблемы в реальном времени.</p>
<h3 id="rusty-probe"><a class="header" href="#rusty-probe">Rusty-probe</a></h3>
<p>Rusty-probe — это открытый USB-основанный аппаратный пробник отладки, предназначенный для работы с probe-rs. Комбинация Rusty-Probe и probe-rs предоставляет простое в использовании, экономичное решение для разработчиков, работающих с приложениями embedded Rust.</p>
<h3 id="st-link"><a class="header" href="#st-link">ST-Link</a></h3>
<p>ST-Link — это популярный пробник отладки и программирования, разработанный STMicroelectronics в основном для серий микроконтроллеров STM32 и STM8. Он поддерживает отладку и программирование через интерфейсы JTAG или SWD (Serial Wire Debug). ST-Link широко используется благодаря прямой поддержке от STMicroelectronics для широкого спектра плат разработки и интеграции в основные IDE, делая его удобным выбором для разработчиков, работающих с микроконтроллерами STM.</p>
<h3 id="j-link"><a class="header" href="#j-link">J-Link</a></h3>
<p>J-Link, разработанный SEGGER Microcontroller, — это надежный и универсальный отладчик, поддерживающий широкий спектр ядер CPU и устройств за пределами ARM, таких как RISC-V. Известный своей высокой производительностью и надежностью, J-Link поддерживает различные интерфейсы связи, включая JTAG, SWD и fine-pitch JTAG. Он популярен благодаря продвинутым функциям, таким как неограниченные точки останова в flash-памяти и совместимость с множеством сред разработки.</p>
<h3 id="mcu-link"><a class="header" href="#mcu-link">MCU-Link</a></h3>
<p>MCU-Link — это пробник отладки, который также функционирует как программатор, предоставляемый NXP Semiconductors. Он поддерживает разнообразные микроконтроллеры ARM Cortex и seamless интегрируется с инструментами разработки вроде MCUXpresso IDE. MCU-Link особенно известен своей универсальностью и доступностью, делая его доступным вариантом для хоббиистов, преподавателей и профессиональных разработчиков.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Установка-инструментов"><a class="header" href="#Установка-инструментов">Установка инструментов</a></h1>
<p>Эта страница содержит инструкции по установке некоторых инструментов, не зависящие от ОС:</p>
<h3 id="Цепочка-инструментов-rust"><a class="header" href="#Цепочка-инструментов-rust">Цепочка инструментов Rust</a></h3>
<p>Установите rustup, следуя инструкциям на <a href="https://rustup.rs">https://rustup.rs</a>.</p>
<p><strong>ПРИМЕЧАНИЕ</strong> Убедитесь, что у вас версия компилятора не ниже 1.31. Команда <code>rustc -V</code> должна возвращать дату новее указанной ниже.</p>
<pre><code class="language-text">$ rustc -V
rustc 1.31.1 (b6c32da9b 2018-12-18)
</code></pre>
<p>Для экономии трафика и места на диске установка по умолчанию поддерживает только нативную компиляцию. Чтобы добавить поддержку кросс-компиляции для архитектур ARM Cortex-M, выберите один из следующих целевых объектов компиляции. Для платы STM32F3DISCOVERY, используемой в примерах этой книги, используйте цель <code>thumbv7em-none-eabihf</code>.
<a href="https://developer.arm.com/ip-products/processors/cortex-m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133">Найдите подходящий Cortex-M для вас.</a></p>
<p>Cortex-M0, M0+ и M1 (архитектура ARMv6-M):</p>
<pre><code class="language-console">rustup target add thumbv6m-none-eabi
</code></pre>
<p>Cortex-M3 (архитектура ARMv7-M):</p>
<pre><code class="language-console">rustup target add thumbv7m-none-eabi
</code></pre>
<p>Cortex-M4 и M7 без аппаратной поддержки операций с плавающей запятой (архитектура ARMv7E-M):</p>
<pre><code class="language-console">rustup target add thumbv7em-none-eabi
</code></pre>
<p>Cortex-M4F и M7F с аппаратной поддержкой операций с плавающей запятой (архитектура ARMv7E-M):</p>
<pre><code class="language-console">rustup target add thumbv7em-none-eabihf
</code></pre>
<p>Cortex-M23 (архитектура ARMv8-M):</p>
<pre><code class="language-console">rustup target add thumbv8m.base-none-eabi
</code></pre>
<p>Cortex-M33 и M35P (архитектура ARMv8-M):</p>
<pre><code class="language-console">rustup target add thumbv8m.main-none-eabi
</code></pre>
<p>Cortex-M33F и M35PF с аппаратной поддержкой операций с плавающей запятой (архитектура ARMv8-M):</p>
<pre><code class="language-console">rustup target add thumbv8m.main-none-eabihf
</code></pre>
<h3 id="cargo-binutils-1"><a class="header" href="#cargo-binutils-1"><code>cargo-binutils</code></a></h3>
<pre><code class="language-text">cargo install cargo-binutils

rustup component add llvm-tools
</code></pre>
<p>WINDOWS: убедитесь, что установлены C++ Build Tools для Visual Studio 2019. https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=16</p>
<h3 id="cargo-generate"><a class="header" href="#cargo-generate"><code>cargo-generate</code></a></h3>
<p>Мы используем это позже для генерации проекта из шаблона.</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<p>Примечание: в некоторых дистрибутивах Linux (например, Ubuntu) может потребоваться установка пакетов <code>libssl-dev</code> и <code>pkg-config</code> перед установкой cargo-generate.</p>
<h3 id="Инструкции-специфичные-для-ОС"><a class="header" href="#Инструкции-специфичные-для-ОС">Инструкции, специфичные для ОС</a></h3>
<p>Теперь следуйте инструкциям, специфичным для вашей ОС:</p>
<ul>
<li><a href="intro/install/linux.html">Linux</a></li>
<li><a href="intro/install/windows.html">Windows</a></li>
<li><a href="intro/install/macos.html">macOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>Вот команды установки для нескольких дистрибутивов Linux.</p>
<h2 id="Пакеты"><a class="header" href="#Пакеты">Пакеты</a></h2>
<ul>
<li>Ubuntu 18.04 или новее / Debian stretch или новее</li>
</ul>
<blockquote>
<p><strong>ПРИМЕЧАНИЕ</strong> <code>gdb-multiarch</code> — это команда GDB, которую вы будете использовать для отладки программ для ARM Cortex-M</p>
</blockquote>
<!-- Debian stretch -->
<!-- GDB 7.12 -->
<!-- OpenOCD 0.9.0 -->
<!-- QEMU 2.8.1 -->
<!-- Ubuntu 18.04 -->
<!-- GDB 8.1 -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.11.1 -->
<pre><code class="language-console">sudo apt install gdb-multiarch openocd qemu-system-arm
</code></pre>
<ul>
<li>Ubuntu 14.04 и 16.04</li>
</ul>
<blockquote>
<p><strong>ПРИМЕЧАНИЕ</strong> <code>arm-none-eabi-gdb</code> — это команда GDB, которую вы будете использовать для отладки программ для ARM Cortex-M</p>
</blockquote>
<!-- Ubuntu 14.04 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.7.0 (?) -->
<!-- QEMU 2.0.0 (?) -->
<pre><code class="language-console">sudo apt install gdb-arm-none-eabi openocd qemu-system-arm
</code></pre>
<ul>
<li>Fedora 27 или новее</li>
</ul>
<!-- Fedora 27 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.10.2 -->
<pre><code class="language-console">sudo dnf install gdb openocd qemu-system-arm
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<blockquote>
<p><strong>ПРИМЕЧАНИЕ</strong> <code>arm-none-eabi-gdb</code> — это команда GDB, которую вы будете использовать для отладки программ для ARM Cortex-M</p>
</blockquote>
<pre><code class="language-console">sudo pacman -S arm-none-eabi-gdb qemu-system-arm openocd
</code></pre>
<h2 id="Правила-udev"><a class="header" href="#Правила-udev">Правила udev</a></h2>
<p>Это правило позволяет использовать OpenOCD с платой Discovery без привилегий root.</p>
<p>Создайте файл <code>/etc/udev/rules.d/70-st-link.rules</code> с содержимым, показанным ниже.</p>
<pre><code class="language-text"># STM32F3DISCOVERY rev A/B - ST-LINK/V2
ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3748", TAG+="uaccess"

# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1
ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374b", TAG+="uaccess"
</code></pre>
<p>Затем перезагрузите все правила udev с помощью:</p>
<pre><code class="language-console">sudo udevadm control --reload-rules
</code></pre>
<p>Если плата была подключена к вашему ноутбуку, отключите ее и подключите заново.</p>
<p>Вы можете проверить разрешения, выполнив эту команду:</p>
<pre><code class="language-console">lsusb
</code></pre>
<p>Которая должна показать что-то вроде</p>
<pre><code class="language-text">(..)
Bus 001 Device 018: ID 0483:374b STMicroelectronics ST-LINK/V2.1
(..)
</code></pre>
<p>Запишите номера шины и устройства. Используйте эти номера для создания пути вроде <code>/dev/bus/usb/&lt;bus&gt;/&lt;device&gt;</code>. Затем используйте этот путь так:</p>
<pre><code class="language-console">ls -l /dev/bus/usb/001/018
</code></pre>
<pre><code class="language-text">crw-------+ 1 root root 189, 17 Sep 13 12:34 /dev/bus/usb/001/018
</code></pre>
<pre><code class="language-console">getfacl /dev/bus/usb/001/018 | grep user
</code></pre>
<pre><code class="language-text">user::rw-
user:you:rw-
</code></pre>
<p><code>+</code>, добавленный к разрешениям, указывает на наличие расширенного разрешения. Команда <code>getfacl</code> показывает, что пользователь <code>you</code> может использовать это устройство.</p>
<p>Теперь перейдите к <a href="intro/install/verify.html">следующему разделу</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>Все инструменты можно установить с помощью <a href="http://brew.sh/">Homebrew</a> или <a href="https://www.macports.org/">MacPorts</a>:</p>
<h2 id="Установка-инструментов-с-homebrew"><a class="header" href="#Установка-инструментов-с-homebrew">Установка инструментов с <a href="http://brew.sh/">Homebrew</a></a></h2>
<pre><code class="language-text">$ # GDB
$ brew install arm-none-eabi-gdb

$ # OpenOCD
$ brew install openocd

$ # QEMU
$ brew install qemu
</code></pre>
<blockquote>
<p><strong>ПРИМЕЧАНИЕ</strong> Если OpenOCD падает, может потребоваться установка последней версии с помощью:</p>
</blockquote>
<pre><code class="language-text">$ brew install --HEAD openocd
</code></pre>
<h2 id="Установка-инструментов-с-macports"><a class="header" href="#Установка-инструментов-с-macports">Установка инструментов с <a href="https://www.macports.org/">MacPorts</a></a></h2>
<pre><code class="language-text">$ # GDB
$ sudo port install arm-none-eabi-gcc

$ # OpenOCD
$ sudo port install openocd

$ # QEMU
$ sudo port install qemu
</code></pre>
<p>Это все! Перейдите к <a href="intro/install/verify.html">следующему разделу</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<h2 id="arm-none-eabi-gdb"><a class="header" href="#arm-none-eabi-gdb"><code>arm-none-eabi-gdb</code></a></h2>
<p>ARM предоставляет установщики <code>.exe</code> для Windows. Возьмите один отсюда <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">gcc</a> и следуйте инструкциям.
Непосредственно перед завершением процесса установки отметьте опцию "Add path to environment variable".
Затем проверьте, что инструменты в вашем <code>%PATH%</code>:</p>
<pre><code class="language-text">$ arm-none-eabi-gdb -v
GNU gdb (GNU Tools for Arm Embedded Processors 7-2018-q2-update) 8.1.0.20180315-git
(..)
</code></pre>
<h2 id="openocd-1"><a class="header" href="#openocd-1">OpenOCD</a></h2>
<p>Официального бинарного релиза OpenOCD для Windows нет, но если вы не в настроении компилировать его самостоятельно, проект xPack предоставляет бинарную дистрибуцию <a href="https://xpack.github.io/openocd/">здесь</a>. Следуйте предоставленным инструкциям по установке. Затем обновите переменную окружения <code>%PATH%</code>, чтобы включить путь, куда были установлены бинарные файлы. (<code>C:\Users\USERNAME\AppData\Roaming\xPacks\@xpack-dev-tools\openocd\0.10.0-13.1\.content\bin\</code>,
если вы использовали простую установку)</p>
<p>Проверьте, что OpenOCD в вашем <code>%PATH%</code> с помощью:</p>
<pre><code class="language-text">$ openocd -v
Open On-Chip Debugger 0.10.0
(..)
</code></pre>
<h2 id="qemu"><a class="header" href="#qemu">QEMU</a></h2>
<p>Возьмите QEMU с <a href="https://www.qemu.org/download/#windows">официального сайта</a>.</p>
<h2 id="Драйвер-usb-st-link"><a class="header" href="#Драйвер-usb-st-link">Драйвер USB ST-LINK</a></h2>
<p>Вам также потребуется установить <a href="http://www.st.com/en/embedded-software/stsw-link009.html">этот драйвер USB</a>, иначе OpenOCD не будет работать. Следуйте инструкциям установщика и убедитесь, что устанавливаете правильную версию (32-битную или 64-битную) драйвера.</p>
<p>Это все! Перейдите к <a href="intro/install/verify.html">следующему разделу</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Проверка-установки"><a class="header" href="#Проверка-установки">Проверка установки</a></h1>
<p>В этом разделе мы проверяем, что некоторые требуемые инструменты / драйверы были правильно установлены и настроены.</p>
<p>Подключите ваш ноутбук / ПК к плате discovery с помощью кабеля Mini-USB. Плата discovery имеет два разъема USB; используйте тот, с меткой "USB ST-LINK", который находится в центре края платы.</p>
<p>Также проверьте, что заголовок ST-LINK установлен. Смотрите картинку ниже; заголовок ST-LINK выделен.</p>
<p align="center">
<img title="Подключенная плата discovery" src="intro/install/../../assets/verify.jpeg">
</p>
<p>Теперь выполните следующую команду:</p>
<pre><code class="language-console">openocd -f interface/stlink.cfg -f target/stm32f3x.cfg
</code></pre>
<blockquote>
<p><strong>ПРИМЕЧАНИЕ</strong>: Старые версии openocd, включая релиз 0.10.0 от 2017 года, не содержат новый (и предпочтительный) файл <code>interface/stlink.cfg</code>; вместо этого может потребоваться использовать <code>interface/stlink-v2.cfg</code> или <code>interface/stlink-v2-1.cfg</code>.</p>
</blockquote>
<p>Вы должны получить следующий вывод, и программа заблокирует консоль:</p>
<pre><code class="language-text">Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "hla_swd". To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.919881
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>Содержимое может не совпадать точно, но вы должны получить последнюю строку о точках останова и наблюдения. Если вы получили ее, завершите процесс OpenOCD и перейдите к <a href="intro/install/../../start/index.html">следующему разделу</a>.</p>
<p>Если вы не получили строку "breakpoints", попробуйте одну из следующих команд.</p>
<pre><code class="language-console">openocd -f interface/stlink-v2.cfg -f target/stm32f3x.cfg
</code></pre>
<pre><code class="language-console">openocd -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg
</code></pre>
<p>Если одна из этих команд работает, это значит, что у вас старая аппаратная ревизия платы discovery. Это не будет проблемой, но запомните этот факт, поскольку вам потребуется немного по-другому настроить вещи позже. Вы можете перейти к <a href="intro/install/../../start/index.html">следующему разделу</a>.</p>
<p>Если ни одна из команд не работает от обычного пользователя, попробуйте запустить их с правами root (например, <code>sudo openocd ..</code>). Если команды работают с правами root, проверьте, что <a href="intro/install/linux.html#udev-rules">правила udev</a> установлены правильно.</p>
<p>Если вы дошли до этого момента и OpenOCD не работает, пожалуйста, откройте <a href="https://github.com/rust-embedded/book/issues">issue</a>, и мы поможем вам!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Начало-работы"><a class="header" href="#Начало-работы">Начало работы</a></h1>
<p>В этом разделе мы проведем вас через процесс написания, сборки, прошивки и отладки встраиваемых программ. Вы сможете попробовать большинство примеров без специального оборудования, поскольку мы покажем основы с использованием QEMU, популярного эмулятора аппаратного обеспечения с открытым исходным кодом. Единственный раздел, где требуется оборудование, — это, естественно, раздел <a href="start/./hardware.html">Аппаратное обеспечение</a>, где мы используем OpenOCD для программирования платы <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qemu-1"><a class="header" href="#qemu-1">QEMU</a></h1>
<p>Мы начнем с написания программы для <a href="http://www.ti.com/product/LM3S6965">LM3S6965</a>, микроконтроллера Cortex-M3. Мы выбрали его в качестве начальной цели, потому что он <a href="https://wiki.qemu.org/Documentation/Platforms/ARM#Supported_in_qemu-system-arm">может быть эмулирован</a> с использованием QEMU, так что в этом разделе вам не придется возиться с оборудованием, и мы сможем сосредоточиться на инструментах и процессе разработки.</p>
<p><strong>ВАЖНО</strong><br />
В этом руководстве мы будем использовать имя "app" для проекта. Везде, где вы видите слово "app", заменяйте его на имя, которое вы выбрали для своего проекта. Или вы можете назвать свой проект "app" и избежать замен.</p>
<h2 id="Создание-нестандартной-программы-на-rust"><a class="header" href="#Создание-нестандартной-программы-на-rust">Создание нестандартной программы на Rust</a></h2>
<p>Мы будем использовать шаблон проекта <a href="https://github.com/rust-embedded/cortex-m-quickstart"><code>cortex-m-quickstart</code></a> для создания нового проекта. Созданный проект будет содержать базовое приложение: хорошую отправную точку для нового встраиваемого приложения на Rust. Кроме того, проект будет содержать директорию <code>examples</code> с несколькими отдельными приложениями, демонстрирующими ключевые функции встраиваемого Rust.</p>
<h3 id="Использование-cargo-generate"><a class="header" href="#Использование-cargo-generate">Использование <code>cargo-generate</code></a></h3>
<p>Сначала установите <code>cargo-generate</code>:</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<p>Затем создайте новый проект:</p>
<pre><code class="language-console">cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
</code></pre>
<pre><code class="language-text"> Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app
</code></pre>
<pre><code class="language-console">cd app
</code></pre>
<h3 id="Использование-git"><a class="header" href="#Использование-git">Использование <code>git</code></a></h3>
<p>Склонируйте репозиторий:</p>
<pre><code class="language-console">git clone https://github.com/rust-embedded/cortex-m-quickstart app
cd app
</code></pre>
<p>Затем заполните заполнители в файле <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
authors = ["{{authors}}"] # "{{authors}}" -&gt; "John Smith"
edition = "2018"
name = "{{project-name}}" # "{{project-name}}" -&gt; "app"
version = "0.1.0"
</code></pre>
<p>Теперь давайте настроим отладку в GDB, чтобы увидеть, как работает программа. Мы будем использовать пример <code>hello.rs</code> из директории <code>examples</code>.</p>
<p>Сначала скомпилируйте пример:</p>
<pre><code class="language-console">cargo build --example hello
</code></pre>
<p>Запустите QEMU в одном терминале:</p>
<pre><code class="language-console">cargo run --example hello
</code></pre>
<p>В другом терминале запустите GDB:</p>
<pre><code class="language-console">arm-none-eabi-gdb target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<p>В GDB подключитесь к QEMU:</p>
<pre><code class="language-console">(gdb) target remote :1234
</code></pre>
<p>Теперь вы можете установить точку останова на функции <code>Reset</code>, которая является точкой входа программы:</p>
<pre><code class="language-console">(gdb) break Reset
Breakpoint 1 at 0x8000942: file src/lib.rs, line 473.
</code></pre>
<p>Запустите программу до точки останова:</p>
<pre><code class="language-console">(gdb) continue
Continuing.

Breakpoint 1, app::__cortex_m_rt_reset () at src/lib.rs:473
473     unsafe extern "C" fn Reset() -&gt; ! {
</code></pre>
<blockquote>
<p><strong>ПРИМЕЧАНИЕ</strong>: Если при установке точки останова на <code>Reset</code>, как показано выше, GDB выдает предупреждения вроде:</p>
<p><code>core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254</code><br />
<code>    src/libcore/num/bignum.rs: No such file or directory.</code></p>
<p>Это известная ошибка. Вы можете спокойно игнорировать эти предупреждения, скорее всего, вы находитесь в <code>Reset()</code>.</p>
</blockquote>
<p>Этот обработчик сброса в конечном итоге вызовет нашу основную функцию. Давайте пропустим все до нее, используя точку останова и команду <code>continue</code>. Сначала посмотрим, где мы хотим установить точку останова, с помощью команды <code>list</code>:</p>
<pre><code class="language-console">list main
</code></pre>
<p>Это покажет исходный код из файла <code>examples/hello.rs</code>:</p>
<pre><code class="language-text">6       use panic_halt as _;
7
8       use cortex_m_rt::entry;
9       use cortex_m_semihosting::{debug, hprintln};
10
11      #[entry]
12      fn main() -&gt; ! {
13          hprintln!("Hello, world!").unwrap();
14
15          // Выход из QEMU
</code></pre>
<p>Мы хотим установить точку останова перед "Hello, world!", которая находится на строке 13. Сделайте это с помощью команды <code>break</code>:</p>
<pre><code class="language-console">break 13
</code></pre>
<p>Теперь мы можем указать GDB запустить программу до нашей основной функции с помощью команды <code>continue</code>:</p>
<pre><code class="language-console">continue
</code></pre>
<pre><code class="language-text">Continuing.

Breakpoint 1, hello::__cortex_m_rt_main () at examples\hello.rs:13
13          hprintln!("Hello, world!").unwrap();
</code></pre>
<p>Теперь мы близки к коду, который выводит "Hello, world!". Давайте продвинемся вперед с помощью команды <code>next</code>:</p>
<pre><code class="language-console">next
</code></pre>
<pre><code class="language-text">16          debug::exit(debug::EXIT_SUCCESS);
</code></pre>
<p>На этом этапе вы должны увидеть "Hello, world!" в терминале, где запущен <code>qemu-system-arm</code>:</p>
<pre><code class="language-text">$ qemu-system-arm (..)
Hello, world!
</code></pre>
<p>Вызов <code>next</code> еще раз завершит процесс QEMU:</p>
<pre><code class="language-console">next
</code></pre>
<pre><code class="language-text">[Inferior 1 (Remote target) exited normally]
</code></pre>
<p>Теперь вы можете выйти из сессии GDB:</p>
<pre><code class="language-console">quit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Аппаратное-обеспечение"><a class="header" href="#Аппаратное-обеспечение">Аппаратное обеспечение</a></h1>
<p>К этому моменту вы уже должны быть немного знакомы с инструментами и процессом разработки. В этом разделе мы перейдем к реальному аппаратному обеспечению; процесс останется в основном тем же. Давайте начнем.</p>
<h2 id="Знайте-ваше-оборудование"><a class="header" href="#Знайте-ваше-оборудование">Знайте ваше оборудование</a></h2>
<p>Перед началом вам нужно определить некоторые характеристики целевого устройства, поскольку они будут использоваться для настройки проекта:</p>
<ul>
<li>Ядро ARM. Например, Cortex-M3.</li>
<li>Есть ли у ядра ARM FPU? Ядра Cortex-M4<strong>F</strong> и Cortex-M7<strong>F</strong> имеют FPU.</li>
<li>Сколько флэш-памяти и оперативной памяти имеет целевое устройство? Например, 256 КиБ флэш-памяти и 32 КиБ оперативной памяти.</li>
<li>Где отображаются флэш-память и оперативная память в адресном пространстве? Например, оперативная память обычно располагается по адресу <code>0x2000_0000</code>.</li>
</ul>
<p>Эту информацию можно найти в техническом описании или справочном руководстве вашего устройства.</p>
<p>В этом разделе мы будем использовать наше эталонное оборудование — плату STM32F3DISCOVERY. Эта плата содержит микроконтроллер STM32F303VCT6. Этот микроконтроллер имеет:</p>
<ul>
<li>Ядро Cortex-M4F с однопрецизионным FPU.</li>
<li>256 КиБ флэш-памяти, расположенной по адресу <code>0x0800_0000</code>.</li>
<li>40 КиБ оперативной памяти, расположенной по адресу <code>0x2000_0000</code>. (Есть еще одна область оперативной памяти, но для простоты мы ее проигнорируем).</li>
</ul>
<h2 id="Настройка"><a class="header" href="#Настройка">Настройка</a></h2>
<p>Мы начнем с нуля с новым экземпляром шаблона. Обратитесь к [предыдущему разделу о QEMU] для напоминания о том, как это сделать без использования <code>cargo-generate</code>.</p>
<pre><code class="language-text">$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
 Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app

$ cd app
</code></pre>
<p>Первым шагом является установка целевого компилятора по умолчанию в файле <code>.cargo/config.toml</code>.</p>
<pre><code class="language-console">tail -n5 .cargo/config.toml
</code></pre>
<pre><code class="language-toml"># Выберите ОДИН из этих целей компиляции
# target = "thumbv6m-none-eabi...
</code></pre>
<p>Теперь нам нужно создать GDB-скрипт для загрузки программы и взаимодействия с платой. В шаблоне уже есть один GDB-скрипт с именем <code>openocd.gdb</code>, созданный на этапе <code>cargo generate</code>, и он должен работать без изменений. Давайте взглянем на него:</p>
<pre><code class="language-console">cat openocd.gdb
</code></pre>
<pre><code class="language-text">target extended-remote :3333

# Печать деманглированных символов
set print asm-demangle on

# Обнаружение необработанных исключений, жестких сбоев и паник
break DefaultHandler
break HardFault
break rust_begin_unwind

monitor arm semihosting enable

load

# Запуск процесса с немедленной остановкой процессора
stepi
</code></pre>
<p>Теперь выполнение команды <code>&lt;gdb&gt; -x openocd.gdb target/thumbv7em-none-eabihf/debug/examples/hello</code> немедленно подключит GDB к OpenOCD, включит семихостинг, загрузит программу и запустит процесс.</p>
<p>Альтернативно, вы можете превратить <code>&lt;gdb&gt; -x openocd.gdb</code> в пользовательский запускатель, чтобы <code>cargo run</code> одновременно компилировал программу <em>и</em> запускал сессию GDB. Этот запускатель включен в <code>.cargo/config.toml</code>, но закомментирован.</p>
<pre><code class="language-console">head -n10 .cargo/config.toml
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
# Раскомментируйте это, чтобы `cargo run` запускал программы на QEMU
# runner = "qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel"

[target.'cfg(all(target_arch = "arm", target_os = "none"))']
# Раскомментируйте ОДИН из этих трех вариантов, чтобы `cargo run` запускал сессию GDB
# Какой вариант выбрать, зависит от вашей системы
runner = "arm-none-eabi-gdb -x openocd.gdb"
# runner = "gdb-multiarch -x openocd.gdb"
# runner = "gdb -x openocd.gdb"
</code></pre>
<pre><code class="language-text">$ cargo run --example hello
(..)
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x1e70 lma 0x8000400
Loading section .rodata, size 0x61c lma 0x8002270
Start address 0x800144e, load size 10380
Transfer rate: 17 KB/sec, 3460 bytes/write.
(gdb)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отображенные-в-память-регистры"><a class="header" href="#Отображенные-в-память-регистры">Отображенные в память регистры</a></h1>
<p>Встраиваемые системы могут зайти только так далеко, выполняя обычный код на Rust и перемещая данные в оперативной памяти. Если мы хотим получать информацию в систему или из нее (будь то мигание светодиода, обнаружение нажатия кнопки или взаимодействие с внешним периферийным устройством по какой-либо шине), нам придется погрузиться в мир периферийных устройств и их "отображенных в память регистров".</p>
<p>Вы можете обнаружить, что код, необходимый для доступа к периферийным устройствам вашего микроконтроллера, уже написан на одном из следующих уровней:</p>
<p align="center">
<img title="Общие крейты" src="start/../assets/crates.png">
</p>
<ul>
<li>Крейт микроархитектуры — этот тип крейта предоставляет полезные процедуры, общие для ядра процессора, используемого вашим микроконтроллером, а также любые периферийные устройства, общие для всех микроконтроллеров, использующих этот тип ядра процессора. Например, крейт <a href="https://crates.io/crates/cortex-m">cortex-m</a> предоставляет функции для включения и отключения прерываний, которые одинаковы для всех микроконтроллеров на базе Cortex-M. Он также предоставляет доступ к периферийному устройству 'SysTick', включенному во все микроконтроллеры на базе Cortex-M.</li>
<li>Крейт доступа к периферийным устройствам (PAC) — этот тип крейта представляет собой тонкую обертку над различными отображенными в память регистрами, определенными для конкретного номера детали вашего микроконтроллера. Например, <a href="https://crates.io/crates/tm4c123x">tm4c123x</a> для серии Texas Instruments Tiva-C TM4C123 или <a href="https://crates.io/crates/stm32f30x">stm32f30x</a> для серии ST-Micro STM32F30x. Здесь вы будете взаимодействовать с регистрами напрямую, следуя инструкциям по эксплуатации каждого периферийного устройства, приведенным в техническом справочном руководстве вашего микроконтроллера.</li>
<li>Крейт HAL — эти крейты предлагают более удобный API для вашего конкретного процессора, часто реализуя общие трейты, определенные в <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>. Например, этот крейт может предлагать структуру <code>Serial</code> с конструктором, который принимает подходящий набор пинов GPIO и скорость передачи данных, и предоставляет функцию <code>write_byte</code> для отправки данных.</li>
</ul>
<p>Давайте рассмотрим пример:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use panic_halt as _; // Обработчик паники

use cortex_m_rt::entry;
use tm4c123x_hal as hal;
use tm4c123x_hal::prelude::*;
use tm4c123x_hal::serial::{NewlineMode, Serial};
use tm4c123x_hal::sysctl;

#[entry]
fn main() -&gt; ! {
    let p = hal::Peripherals::take().unwrap();
    let cp = hal::CorePeripherals::take().unwrap();

    // Обертывание структуры SYSCTL в объект с API более высокого уровня
    let mut sc = p.SYSCTL.constrain();
    // Выбор настроек осциллятора
    sc.clock_setup.oscillator = sysctl::Oscillator::Main(
        sysctl::CrystalFrequency::_16mhz,
        sysctl::SystemClock::UsePll(sysctl::PllOutputFrequency::_80_00mhz),
    );
    // Настройка PLL с этими параметрами
    let clocks = sc.clock_setup.freeze();

    // Обертывание структуры GPIO_PORTA в объект с API более высокого уровня.
    // Обратите внимание, что требуется заимствование `sc.power_control` для автоматического включения питания периферийного устройства GPIO
    let mut porta = p.GPIO_PORTA.split(&amp;sc.power_control);

    // Активация UART.
    let uart = Serial::uart0(
        p.UART0,
        // Пин передачи
        porta
            .pa1
            .into_af_push_pull::&lt;hal::gpio::AF1&gt;(&amp;mut porta.control),
        // Пин приема
        porta
            .pa0
            .into_af_push_pull::&lt;hal::gpio::AF1&gt;(&amp;mut porta.control),
        // RTS или CTS не требуются
        (),
        (),
        // Скорость передачи данных
        115200_u32.bps(),
        // Обработка вывода
        NewlineMode::SwapLFtoCRLF,
        // Нам нужны частоты часов для расчета делителей скорости передачи
        &amp;clocks,
        // Это необходимо для включения питания периферийного устройства UART
        &amp;sc.power_control,
    );

    loop {
        writeln!(uart, "Hello, World!\r\n").unwrap();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Семихостинг"><a class="header" href="#Семихостинг">Семихостинг</a></h1>
<p>Семихостинг — это механизм, который позволяет встраиваемым устройствам выполнять ввод/вывод на хосте и в основном используется для записи сообщений в консоль хоста. Семихостинг требует отладочной сессии и почти ничего больше (никаких дополнительных проводов!), поэтому его очень удобно использовать. Недостаток в том, что он очень медленный: каждая операция записи может занимать несколько миллисекунд в зависимости от используемого аппаратного отладчика (например, ST-Link).</p>
<p>Крейт <a href="https://crates.io/crates/cortex-m-semihosting"><code>cortex-m-semihosting</code></a> предоставляет API для выполнения операций семихостинга на устройствах Cortex-M. Программа ниже — это версия "Hello, world!" с использованием семихостинга:</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_halt as _;

use cortex_m_rt::entry;
use cortex_m_semihosting::hprintln;

#[entry]
fn main() -&gt; ! {
    hprintln!("Hello, world!").unwrap();

    loop {}
}</code></pre>
<p>Если вы запустите эту программу на оборудовании, вы увидите сообщение "Hello, world!" в логах OpenOCD.</p>
<pre><code class="language-text">$ openocd
(..)
Hello, world!
(..)
</code></pre>
<p>Вам нужно сначала включить семихостинг в OpenOCD из GDB:</p>
<pre><code class="language-console">(gdb) monitor arm semihosting enable
semihosting is enabled
</code></pre>
<p>QEMU понимает операции семихостинга, поэтому приведенная выше программа также будет работать с <code>qemu-system-arm</code> без необходимости запуска отладочной сессии. Обратите внимание, что вам нужно передать флаг <code>-semihosting-config</code> в QEMU для включения поддержки семихостинга; эти флаги уже включены в файл <code>.cargo/config.toml</code> шаблона.</p>
<pre><code class="language-text">$ # Эта программа заблокирует терминал
$ cargo run
     Running `qemu-system-arm (..)
Hello, world!
</code></pre>
<p>Существует также операция семихостинга <code>exit</code>, которая может быть использована для завершения процесса QEMU. Важно: <strong>не</strong> используйте <code>debug::exit</code> на оборудовании; эта функция может повредить вашу сессию OpenOCD, и вы не сможете отлаживать другие программы, пока не перезапустите ее.</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_halt as _;

use cortex_m_rt::entry;
use cortex_m_semihosting::debug;

#[entry]
fn main() -&gt; ! {
    let roses = "blue";

    if roses == "red" {
        debug::exit(debug::EXIT_SUCCESS);
    } else {
        debug::exit(debug::EXIT_FAILURE);
    }

    loop {}
}</code></pre>
<pre><code class="language-text">$ cargo run
     Running `qemu-system-arm (..)

$ echo $?
1
</code></pre>
<p>Один последний совет: вы можете настроить поведение паники на <code>exit(EXIT_FAILURE)</code>. Это позволит вам писать тесты <code>no_std</code> с проверкой прохождения, которые можно запускать на QEMU.</p>
<p>Для удобства крейт <code>panic-semihosting</code> имеет функцию "exit", которая при включении вызывает <code>exit(EXIT_FAILURE)</code> после записи сообщения о панике в stderr хоста.</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_semihosting as _; // features = ["exit"]

use cortex_m_rt::entry;
use cortex_m_semihosting::debug;

#[entry]
fn main() -&gt; ! {
    let roses = "blue";

    assert_eq!(roses, "red");

    loop {}
}</code></pre>
<pre><code class="language-text">$ cargo run
     Running `qemu-system-arm (..)
panicked at 'assertion failed: `(left == right)`
  left: `"blue"`,
 right: `"red"`', examples/hello.rs:15:5

$ echo $?
1
</code></pre>
<p><strong>ПРИМЕЧАНИЕ</strong>: Чтобы включить эту функцию в <code>panic-semihosting</code>, отредактируйте раздел зависимостей в <code>Cargo.toml</code>, где указан <code>panic-semihosting</code>:</p>
<pre><code class="language-toml">panic-semihosting = { version = "VERSION", features = ["exit"] }
</code></pre>
<p>где <code>VERSION</code> — желаемая версия. Для получения дополнительной информации о функциях зависимостей обратитесь к разделу <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html"><code>указание зависимостей</code></a> книги Cargo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Паника"><a class="header" href="#Паника">Паника</a></h1>
<p>Паника — это основная часть языка Rust. Встроенные операции, такие как индексация, проверяются во время выполнения на предмет безопасности памяти. При попытке индексации за пределами границ массива возникает паника.</p>
<p>В стандартной библиотеке поведение паники определено: оно разворачивает стек вызывающего потока, если пользователь не выбрал завершение программы при панике.</p>
<p>Однако в программах без стандартной библиотеки поведение паники остается неопределенным. Поведение можно выбрать, объявив функцию <code>#[panic_handler]</code>. Эта функция должна появляться ровно <em>один раз</em> в графе зависимостей программы и иметь следующую сигнатуру: <code>fn(&amp;PanicInfo) -&gt; !</code>, где <a href="https://doc.rust-lang.org/core/panic/struct.PanicInfo.html"><code>PanicInfo</code></a> — это структура, содержащая информацию о месте возникновения паники.</p>
<p>Учитывая, что встраиваемые системы варьируются от пользовательских до критически важных для безопасности (не могут завершаться сбоем), не существует универсального поведения при панике, но есть множество часто используемых поведений. Эти общие поведения были упакованы в крейты, которые определяют функцию <code>#[panic_handler]</code>. Некоторые примеры включают:</p>
<ul>
<li><a href="https://crates.io/crates/panic-abort"><code>panic-abort</code></a>. Паника вызывает выполнение инструкции прерывания.</li>
<li><a href="https://crates.io/crates/panic-halt"><code>panic-halt</code></a>. Паника приводит к остановке программы или текущего потока в бесконечном цикле.</li>
<li><a href="https://crates.io/crates/panic-itm"><code>panic-itm</code></a>. Сообщение о панике записывается с использованием ITM, периферийного устройства, специфичного для ARM Cortex-M.</li>
<li><a href="https://crates.io/crates/panic-semihosting"><code>panic-semihosting</code></a>. Сообщение о панике отправляется на хост с использованием техники семихостинга.</li>
</ul>
<p>Вы можете найти еще больше крейтов, выполнив поиск по ключевому слову <a href="https://crates.io/keywords/panic-handler"><code>panic-handler</code></a> на crates.io.</p>
<p>Программа может выбрать одно из этих поведений, просто подключив соответствующий крейт...</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

// Профиль dev: упрощает отладку паник; можно установить точку останова на `rust_begin_unwind`
#[cfg(debug_assertions)]
use panic_halt as _;

// Профиль release: минимизирует размер бинарного файла приложения
#[cfg(not(debug_assertions))]
use panic_abort as _;

// ..</code></pre>
<p>В этом примере крейт подключается к <code>panic-halt</code> при сборке с профилем dev (<code>cargo build</code>), но к <code>panic-abort</code> при сборке с профилем release (<code>cargo build --release</code>).</p>
<blockquote>
<p>Форма инструкции <code>use panic_abort as _;</code> используется для обеспечения включения обработчика паники <code>panic_abort</code> в итоговый исполняемый файл, при этом ясно указывая компилятору, что мы не будем явно использовать что-либо из крейта. Без переименования <code>as _</code> компилятор выдал бы предупреждение о неиспользуемом импорте. Иногда можно встретить <code>extern crate panic_abort</code> вместо этого, что является старым стилем, использовавшимся до издания Rust 2018, и теперь должно использоваться только для "sysroot" крейтов (распространяемых вместе с Rust), таких как <code>proc_macro</code>, <code>alloc</code>, <code>std</code> и <code>test</code>.</p>
</blockquote>
<h2 id="Пример"><a class="header" href="#Пример">Пример</a></h2>
<p>Вот пример, который пытается индексировать массив за его пределами. Эта операция приводит к панике.</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_semihosting as _;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    let xs = [0, 1, 2];
    let i = xs.len();
    let _y = xs[i]; // Доступ за пределами массива

    loop {}
}</code></pre>
<p>В этом примере выбрано поведение <code>panic-semihosting</code>, которое выводит сообщение о панике на консоль хоста с использованием семихостинга.</p>
<pre><code class="language-text">$ cargo run
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb (..)
panicked at 'index out of bounds: the len is 3 but the index is 4', src/main.rs:12:13
</code></pre>
<p>Вы можете попробовать изменить поведение на <code>panic-halt</code> и убедиться, что в этом случае сообщение не выводится.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Исключения"><a class="header" href="#Исключения">Исключения</a></h1>
<p>Исключения и прерывания — это аппаратный механизм, с помощью которого процессор обрабатывает асинхронные события и фатальные ошибки (например, выполнение недопустимой инструкции). Исключения подразумевают вытеснение и включают обработчики исключений — подпрограммы, выполняемые в ответ на сигнал, вызвавший событие.</p>
<p>Крейт <code>cortex-m-rt</code> предоставляет атрибут <a href="https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.exception.html"><code>exception</code></a> для объявления обработчиков исключений.</p>
<pre><code class="language-rust ignore">// Обработчик исключения для исключения SysTick (системный таймер)
#[exception]
fn SysTick() {
    // ..
}</code></pre>
<p>Помимо атрибута <code>exception</code>, обработчики исключений выглядят как обычные функции, но есть одно важное различие: обработчики <code>exception</code> <em>нельзя</em> вызывать программно. Например, в приведенном выше примере вызов <code>SysTick();</code> приведет к ошибке компиляции.</p>
<p>Такое поведение намеренное и необходимо для обеспечения следующей особенности: переменные <code>static mut</code>, объявленные <em>внутри</em> обработчиков <code>exception</code>, <em>безопасны</em> для использования.</p>
<pre><code class="language-rust ignore">#[exception]
fn SysTick() {
    static mut COUNT: u32 = 0;

    // `COUNT` преобразуется в тип `&amp;mut u32` и безопасен для использования
    *COUNT += 1;
}</code></pre>
<p>Как известно, использование переменных <code>static mut</code> в функции делает ее <a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)"><em>нереентерабельной</em></a>. Вызов нереентерабельной функции, прямо или косвенно, из нескольких обработчиков исключений/прерываний или из <code>main</code> и одного или более обработчиков исключений/прерываний приводит к неопределенному поведению.</p>
<p>Безопасный Rust никогда не должен приводить к неопределенному поведению, поэтому нереентерабельные функции должны быть помечены как <code>unsafe</code>. Однако, как было сказано, обработчики <code>exception</code> могут безопасно использовать переменные <code>static mut</code>. Это возможно, потому что обработчики <code>exception</code> <em>не могут</em> быть вызваны программно, что исключает возможность реентерабельности. Эти обработчики вызываются самим аппаратным обеспечением...</p>
<blockquote>
<p><strong>ПРИМЕЧАНИЕ</strong>: Этот программный код не будет работать (т.е. не завершится сбоем) на QEMU, поскольку <code>qemu-system-arm -machine lm3s6965evb</code> не проверяет загрузку памяти и с радостью вернет <code>0</code> при чтении из недопустимой памяти.</p>
</blockquote>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_halt as _;

use core::fmt::Write;
use core::ptr;

use cortex_m_rt::{entry, exception, ExceptionFrame};
use cortex_m_semihosting::hio;

#[entry]
fn main() -&gt; ! {
    // Чтение из несуществующего адреса памяти
    unsafe {
        ptr::read_volatile(0x3FFF_0000 as *const u32);
    }

    loop {}
}

#[exception]
fn HardFault(ef: &amp;ExceptionFrame) -&gt; ! {
    if let Ok(mut hstdout) = hio::hstdout() {
        writeln!(hstdout, "{:#?}", ef).ok();
    }

    loop {}
}</code></pre>
<p>Обработчик <code>HardFault</code> выводит значение <code>ExceptionFrame</code>. Если вы запустите этот код, вы увидите что-то вроде этого в консоли OpenOCD:</p>
<pre><code class="language-text">$ openocd
(..)
ExceptionFrame {
    r0: 0x3fff0000,
    r1: 0x00000003,
    r2: 0x080032e8,
    r3: 0x00000000,
    r12: 0x00000000,
    lr: 0x080016df,
    pc: 0x080016e2,
    xpsr: 0x61000000,
}
</code></pre>
<p>Значение <code>pc</code> — это значение программного счетчика на момент исключения, и оно указывает на инструкцию, вызвавшую исключение.</p>
<p>Если посмотреть дизассемблированный код программы:</p>
<pre><code class="language-text">$ cargo objdump --bin app --release -- -d --no-show-raw-insn --print-imm-hex
(..)
ResetTrampoline:
 8000942:       movw    r0, #0xfffe
 8000946:       movt    r0, #0x3fff
 800094a:       ldr     r0, [r0]
 800094c:       b       #-0x4 &lt;ResetTrampoline+0xa&gt;
</code></pre>
<p>Вы можете найти значение программного счетчика <code>0x0800094a</code> в дизассемблированном коде. Вы увидите, что операция загрузки (<code>ldr r0, [r0]</code>) вызвала исключение. Поле <code>r0</code> в <code>ExceptionFrame</code> покажет, что значение регистра <code>r0</code> в этот момент было <code>0x3fff_fffe</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Прерывания"><a class="header" href="#Прерывания">Прерывания</a></h1>
<p>Прерывания отличаются от исключений по ряду параметров, но их работа и использование в основном схожи, и они обрабатываются одним и тем же контроллером прерываний. В то время как исключения определяются архитектурой Cortex-M, прерывания всегда являются специфичными для производителя (и часто даже для конкретной микросхемы) как по именованию, так и по функциональности.</p>
<p>Прерывания предоставляют большую гибкость, которую необходимо учитывать при их использовании в сложных сценариях. В этой книге мы не будем рассматривать такие случаи, но важно помнить следующее:</p>
<ul>
<li>Прерывания имеют программируемые приоритеты, которые определяют порядок выполнения их обработчиков.</li>
<li>Прерывания могут быть вложенными и вытеснять друг друга, т.е. выполнение обработчика прерывания может быть прервано другим прерыванием с более высоким приоритетом.</li>
<li>В общем случае причину, вызвавшую прерывание, необходимо устранить, чтобы предотвратить бесконечное повторное вхождение в обработчик прерывания.</li>
</ul>
<p>Общие шаги инициализации во время выполнения всегда одинаковы:</p>
<ul>
<li>Настройка периферийных устройств для генерации запросов на прерывания в нужных случаях.</li>
<li>Установка желаемого приоритета обработчика прерывания в контроллере прерываний.</li>
<li>Включение обработчика прерывания в контроллере прерываний.</li>
</ul>
<p>Аналогично исключениям, крейт <code>cortex-m-rt</code> предоставляет атрибут <a href="https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html"><code>interrupt</code></a> для объявления обработчиков прерываний. Однако этот атрибут доступен только при включении функции устройства. При этом данный атрибут не предназначен для прямого использования — это приведет к ошибке компиляции.</p>
<p>Вместо этого вы должны использовать переэкспортированную версию атрибута <code>interrupt</code>, предоставляемую крейтом устройства (обычно сгенерированным с помощью <code>svd2rust</code>). Это гарантирует, что компилятор может проверить, существует ли прерывание на целевом устройстве. Список доступных прерываний — и их положение в таблице векторов прерываний — обычно автоматически генерируется из файла SVD с помощью <code>svd2rust</code>.</p>
<pre><code class="language-rust ignore">use lm3s6965::interrupt; // Переэкспортированный атрибут из крейта устройства

// Обработчик прерывания для прерывания Timer2
#[interrupt]
fn TIMER2A() {
    // ..
    // Устранение причины, вызвавшей запрос на прерывание
}</code></pre>
<p>Обработчики прерываний выглядят как обычные функции (за исключением отсутствия аргументов), подобно обработчикам исключений. Однако их нельзя вызывать напрямую другими частями прошивки из-за специальных соглашений о вызове. Тем не менее, можно программно генерировать запросы на прерывания, чтобы вызвать переход к обработчику прерывания.</p>
<p>Подобно обработчикам исключений, в обработчиках прерываний также можно безопасно объявлять переменные <code>static mut</code> для хранения состояния.</p>
<pre><code class="language-rust ignore">#[interrupt]
fn TIMER2A() {
    static mut COUNT: u32 = 0;

    // `COUNT` имеет тип `&amp;mut u32` и безопасен для использования
    *COUNT += 1;
}</code></pre>
<p>Для более подробного описания механизмов, продемонстрированных здесь, обратитесь к [разделу об исключениях].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Вводвывод"><a class="header" href="#Вводвывод">Ввод/вывод</a></h1>
<blockquote>
<p><strong>TODO</strong> Рассмотреть отображение ввода/вывода в память с использованием регистров.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Периферийные-устройства"><a class="header" href="#Периферийные-устройства">Периферийные устройства</a></h1>
<h2 id="Что-такое-периферийные-устройства"><a class="header" href="#Что-такое-периферийные-устройства">Что такое периферийные устройства?</a></h2>
<p>Большинство микроконтроллеров имеют не только процессор, оперативную память или флэш-память — они содержат участки кремния, которые используются для взаимодействия с системами вне микроконтроллера, а также для прямого и косвенного взаимодействия с окружающим миром через датчики, контроллеры двигателей или интерфейсы для человека, такие как дисплей или клавиатура. Эти компоненты в совокупности называются периферийными устройствами.</p>
<p>Эти периферийные устройства полезны, потому что позволяют разработчику переложить обработку на них, избегая необходимости обрабатывать все в программном обеспечении. Подобно тому, как разработчик настольных приложений перекладывает обработку графики на видеокарту, разработчики встраиваемых систем могут переложить некоторые задачи на периферийные устройства, позволяя процессору заниматься чем-то другим важным или вообще ничего не делать, чтобы сэкономить энергию.</p>
<p>Если посмотреть на основную печатную плату старомодного домашнего компьютера 1970-х или 1980-х годов (а на самом деле настольные ПК прошлого не так уж далеки от современных встраиваемых систем), вы ожидаете увидеть:</p>
<ul>
<li>Процессор</li>
<li>Чип оперативной памяти</li>
<li>Чип ПЗУ</li>
<li>Контроллер ввода-вывода</li>
</ul>
<p>Чип оперативной памяти, чип ПЗУ и контроллер ввода-вывода (периферийное устройство в этой системе) будут соединены с процессором через серию параллельных дорожек, известных как "шина". Эта шина передает адресную информацию, которая выбирает, с каким устройством на шине процессор хочет взаимодействовать, и шину данных, которая передает фактические данные. В наших встраиваемых микроконтроллерах применяются те же принципы — просто все упаковано на одном куске кремния.</p>
<p>Однако, в отличие от видеокарт, которые обычно имеют программный API, такой как Vulkan, Metal или OpenGL, периферийные устройства в микроконтроллерах представлены через аппаратный интерфейс, который отображается на участок памяти.</p>
<h2 id="Линейное-и-реальное-адресное-пространство"><a class="header" href="#Линейное-и-реальное-адресное-пространство">Линейное и реальное адресное пространство</a></h2>
<p>На микроконтроллере запись данных по произвольному адресу, например <code>0x4000_0000</code> или <code>0x0000_0000</code>, может быть полностью корректной операцией.</p>
<p>На настольной системе доступ к памяти строго контролируется MMU (Memory Management Unit, блок управления памятью). Этот компонент выполняет две основные функции: обеспечение доступа...</p>
<p>На микроконтроллере адресное пространство используется иначе. Например, как упоминалось в предыдущих главах, оперативная память может быть расположена по адресу <code>0x2000_0000</code>. Если наша оперативная память имеет размер 64 КиБ (т.е. максимальный адрес <code>0x2000_FFFF</code>), то адреса от <code>0x2000_0000</code> до <code>0x2000_FFFF</code> будут соответствовать нашей оперативной памяти. Когда мы записываем в переменную, находящуюся по адресу <code>0x2000_1234</code>, внутри происходит логика, которая определяет верхнюю часть адреса (в данном случае <code>0x2000</code>) и активирует оперативную память, чтобы она могла работать с нижней частью адреса (<code>0x1234</code> в данном случае). На Cortex-M у нас также есть флэш-ПЗУ, отображенное по адресу <code>0x0000_0000</code> до, скажем, адреса <code>0x0007_FFFF</code> (если у нас флэш-ПЗУ на 512 КиБ). Вместо того чтобы игнорировать все оставшееся пространство между этими двумя областями, разработчики микроконтроллеров отобразили интерфейс для периферийных устройств на определенные адреса памяти. Это выглядит примерно так:</p>
<p><img src="peripherals/../assets/nrf52-memory-map.png" alt="" /></p>
<p><a href="http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf">Техническое описание Nordic nRF52832 (pdf)</a></p>
<h2 id="Отображенные-в-память-периферийные-устройства"><a class="header" href="#Отображенные-в-память-периферийные-устройства">Отображенные в память периферийные устройства</a></h2>
<p>Взаимодействие с этими периферийными устройствами на первый взгляд кажется простым — запишите правильные данные по правильному адресу. Например, отправка 32-битного слова через последовательный порт может быть настолько же простой, как запись этого 32-битного слова по определенному адресу памяти. Периферийное устройство последовательного порта затем возьмет на себя задачу и автоматически отправит данные.</p>
<p>Конфигурация этих периферийных устройств работает аналогично. Вместо вызова функции для настройки периферийного устройства предоставляется участок памяти, который служит аппаратным API. Запишите <code>0x8000_0000</code> в регистр конфигурации частоты SPI, и порт SPI будет отправлять данные со скоростью 8 мегабит в секунду. Запишите <code>0x0200_0000</code> по тому же адресу, и порт SPI будет отправлять данные со скоростью 125 килобит в секунду. Эти регистры конфигурации выглядят примерно так:</p>
<p><img src="peripherals/../assets/nrf52-spi-frequency-register.png" alt="" /></p>
<p><a href="http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf">Техническое описание Nordic nRF52832 (pdf)</a></p>
<p>Этот интерфейс — способ взаимодействия с аппаратным обеспечением, независимо от используемого языка, будь то ассемблер, C или Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Первая-попытка"><a class="header" href="#Первая-попытка">Первая попытка</a></h1>
<h2 id="Регистры"><a class="header" href="#Регистры">Регистры</a></h2>
<p>Рассмотрим периферийное устройство 'SysTick' — простой таймер, который поставляется с каждым процессорным ядром Cortex-M. Обычно вы ищете информацию об этом в техническом описании микросхемы или <em>Справочном руководстве</em>, но данный пример общий для всех ядер ARM Cortex-M, поэтому обратимся к [Справочному руководству ARM]. Мы видим, что есть четыре регистра:</p>
<div class="table-wrapper"><table><thead><tr><th>Смещение</th><th>Имя</th><th>Описание</th><th>Ширина</th></tr></thead><tbody>
<tr><td>0x00</td><td>SYST_CSR</td><td>Регистр управления и состояния</td><td>32 бита</td></tr>
<tr><td>0x04</td><td>SYST_RVR</td><td>Регистр значения перезагрузки</td><td>32 бита</td></tr>
<tr><td>0x08</td><td>SYST_CVR</td><td>Регистр текущего значения</td><td>32 бита</td></tr>
<tr><td>0x0C</td><td>SYST_CALIB</td><td>Регистр значения калибровки</td><td>32 бита</td></tr>
</tbody></table>
</div>
<h2 id="Подход-на-c"><a class="header" href="#Подход-на-c">Подход на C</a></h2>
<p>В Rust мы можем представить набор регистров точно так же, как в C — с помощью <code>struct</code>.</p>
<pre><code class="language-rust ignore">#[repr(C)]
struct SysTick {
    pub csr: u32,
    pub rvr: u32,
    pub cvr: u32,
    pub calib: u32,
}</code></pre>
<p>Квалификатор <code>#[repr(C)]</code> указывает компилятору Rust размещать эту структуру так, как это сделал бы компилятор C. Это очень важно, так как Rust позволяет переупорядочивать поля структуры, а C — нет. Представьте, какой отладкой нам пришлось бы заниматься, если бы эти поля были тихо переупорядочены компилятором! С этим квалификатором у нас есть четыре 32-битных поля, соответствующих приведенной выше таблице. Но, конечно, сама по себе эта <code>struct</code> бесполезна — нам нужна переменная.</p>
<pre><code class="language-rust ignore">let systick = 0xE000_E010 as *mut SysTick;
let time = unsafe { (*systick).cvr };</code></pre>
<h2 id="Волатильные-доступы"><a class="header" href="#Волатильные-доступы">Волатильные доступы</a></h2>
<p>В приведенном выше подходе есть несколько проблем.</p>
<ol>
<li>Нам приходится использовать <code>unsafe</code> каждый раз, когда мы хотим получить доступ к нашему периферийному устройству.</li>
<li>У нас нет способа указать, какие регистры предназначены только для чтения, а какие — для чтения и записи.</li>
</ol>
<p>Чтобы решить эти проблемы, мы можем использовать крейт <code>volatile-register</code>, который предоставляет типы <code>RO</code> (только для чтения), <code>WO</code> (только для записи) и <code>RW</code> (чтение/запись). Это позволяет нам определить, какие операции безопасны, и избежать случайной записи в регистр только для чтения.</p>
<p>Кроме того, нам нужно использовать волатильные операции для доступа к памяти, чтобы гарантировать, что компилятор не оптимизирует наши операции чтения или записи. Это достигается с помощью методов <code>read</code> и <code>write</code> из крейта <code>volatile-register</code>.</p>
<h2 id="Обертка-в-стиле-rust"><a class="header" href="#Обертка-в-стиле-rust">Обертка в стиле Rust</a></h2>
<p>Нам нужно обернуть эту <code>struct</code> в API более высокого уровня, который безопасен для вызова пользователями. Как автор драйвера, мы вручную проверяем, что небезопасный код корректен, а затем предоставляем безопасный API для пользователей, чтобы они не беспокоились об этом (при условии, что они доверяют нам, что мы сделали это правильно!).</p>
<p>Пример может выглядеть так:</p>
<pre><code class="language-rust ignore">use volatile_register::{RW, RO};

pub struct SystemTimer {
    p: &amp;'static mut RegisterBlock
}

#[repr(C)]
struct RegisterBlock {
    pub csr: RW&lt;u32&gt;,
    pub rvr: RW&lt;u32&gt;,
    pub cvr: RW&lt;u32&gt;,
    pub calib: RO&lt;u32&gt;,
}

impl SystemTimer {
    pub fn new() -&gt; SystemTimer {
        SystemTimer {
            p: unsafe { &amp;mut *(0xE000_E010 as *mut RegisterBlock) }
        }
    }

    pub fn get_time(&amp;self) -&gt; u32 {
        self.p.cvr.read()
    }

    pub fn set_reload(&amp;mut self, reload_value: u32) {
        unsafe { self.p.rvr.write(reload_value) }
    }
}

pub fn example_usage() -&gt; String {
    let mut st = SystemTimer::new();
    st.set_reload(0x00FF_FFFF);
    format!("Time is now 0x{:08x}", st.get_time())
}</code></pre>
<p>Теперь проблема в том, что следующий код полностью приемлем для компилятора:</p>
<pre><code class="language-rust ignore">fn thread1() {
    let mut st = SystemTimer::new();
    st.set_reload(2000);
}

fn thread2() {
    let mut st = SystemTimer::new();
    st.set_reload(1000);
}</code></pre>
<p>Наш аргумент <code>&amp;mut self</code> в функции <code>set_reload</code> проверяет, что нет других ссылок на <em>этот</em> конкретный экземпляр структуры <code>SystemTimer</code>, но он не мешает пользователю создать второй экземпляр <code>SystemTimer</code>, который указывает на то же самое периферийное устройство! Код, написанный в таком стиле, будет работать, если автор достаточно внимателен, чтобы заметить все эти "дублирующиеся" экземпляры драйвера, но как только код распространяется по нескольким модулям, драйверам, разработчикам и дням, такие ошибки становятся все проще совершать.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Изменяемое-глобальное-состояние"><a class="header" href="#Изменяемое-глобальное-состояние">Изменяемое глобальное состояние</a></h2>
<p>К сожалению, аппаратное обеспечение — это, по сути, не что иное, как изменяемое глобальное состояние, что может пугать разработчика на Rust. Аппаратное обеспечение существует независимо от структур кода, который мы пишем, и может быть изменено в любой момент реальным миром.</p>
<h2 id="Какими-должны-быть-наши-правила"><a class="header" href="#Какими-должны-быть-наши-правила">Какими должны быть наши правила?</a></h2>
<p>Как мы можем надежно взаимодействовать с этими периферийными устройствами?</p>
<ol>
<li>Всегда используйте методы <code>volatile</code> для чтения или записи в память периферийных устройств, так как она может измениться в любой момент.</li>
<li>В программном обеспечении мы должны иметь возможность предоставлять любое количество доступов только для чтения к этим периферийным устройствам.</li>
<li>Если программное обеспечение должно иметь доступ на чтение и запись к периферийному устройству, оно должно быть единственным обладателем ссылки на это устройство.</li>
</ol>
<h2 id="Проверяющий-заимствования"><a class="header" href="#Проверяющий-заимствования">Проверяющий заимствования</a></h2>
<p>Последние два правила подозрительно похожи на то, что уже делает проверяющий заимствования (Borrow Checker)!</p>
<p>Представьте, если бы мы могли передавать владение этими периферийными устройствами или предоставлять неизменяемые или изменяемые ссылки на них?</p>
<p>Мы можем это сделать, но для проверяющего заимствования нам нужно иметь ровно один экземпляр каждого периферийного устройства, чтобы Rust мог корректно это обработать. К счастью, в аппаратном обеспечении есть только один экземпляр любого данного периферийного устройства, но как мы можем отразить это в структуре нашего кода?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Синглтоны"><a class="header" href="#Синглтоны">Синглтоны</a></h1>
<blockquote>
<p>В программной инженерии шаблон синглтон — это шаблон проектирования, который ограничивает создание экземпляров класса одним объектом.</p>
<p><em>Википедия: <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Шаблон синглтон</a></em></p>
</blockquote>
<h2 id="Почему-нельзя-просто-использовать-глобальные-переменные"><a class="header" href="#Почему-нельзя-просто-использовать-глобальные-переменные">Почему нельзя просто использовать глобальные переменные?</a></h2>
<p>Мы могли бы сделать все публичными статическими переменными, например так:</p>
<pre><code class="language-rust ignore">static mut THE_SERIAL_PORT: SerialPort = SerialPort;

fn main() {
    let _ = unsafe {
        THE_SERIAL_PORT.read_speed();
    };
}</code></pre>
<p>Но у этого подхода есть несколько проблем. Это изменяемая глобальная переменная, и в Rust взаимодействие с такими переменными всегда небезопасно. Кроме того, эти переменные видны во всей программе, что означает, что проверяющий заимствования не может помочь вам отслеживать ссылки и владение этими переменными.</p>
<h2 id="Как-это-сделать-в-rust"><a class="header" href="#Как-это-сделать-в-rust">Как это сделать в Rust?</a></h2>
<p>Вместо того чтобы делать наше периферийное устройство глобальной переменной, мы можем создать структуру, в данном случае названную <code>PERIPHERALS</code>, которая содержит <code>Option&lt;T&gt;</code> для каждого из наших периферийных устройств.</p>
<pre><code class="language-rust ignore">struct Peripherals {
    serial: Option&lt;SerialPort&gt;,
}
impl Peripherals {
    fn take_serial(&amp;mut self) -&gt; SerialPort {
        let p = replace(&amp;mut self.serial, None);
        p.unwrap()
    }
}
static mut PERIPHERALS: Peripherals = Peripherals {
    serial: Some(SerialPort),
};</code></pre>
<p>Эта структура позволяет нам получить единственный экземпляр нашего периферийного устройства. Если мы попытаемся вызвать <code>take_serial()</code> более одного раза, наш код вызовет панику!</p>
<pre><code class="language-rust ignore">fn main() {
    let serial_1 = unsafe { PERIPHERALS.take_serial() };
    // Это вызовет панику!
    // let serial_2 = unsafe { PERIPHERALS.take_serial() };
}</code></pre>
<p>Хотя взаимодействие с этой структурой является <code>unsafe</code>, после того как мы получили содержащийся в ней <code>SerialPort</code>, нам больше не нужно использовать <code>unsafe</code> или саму структуру <code>PERIPHERALS</code>.</p>
<p>Это имеет небольшую накладную стоимость во время выполнения, поскольку нам нужно обернуть структуру <code>SerialPort</code> в <code>Option</code>, и нам придется один раз вызвать <code>take_serial()</code>, однако эта небольшая начальная стоимость позволяет нам использовать проверяющий заимствования...</p>
<pre><code class="language-rust ignore">#[entry]
fn main(cx: main::Context) -&gt; ! {
    // Получение доступа к периферийным устройствам ядра
    let core: CorePeripherals = cx.core;
        
    // Устройство-специфичные периферийные устройства
    let device: lm3s6965::Peripherals = cx.device;
}</code></pre>
<h2 id="Но-зачем"><a class="header" href="#Но-зачем">Но зачем?</a></h2>
<p>Но как эти синглтоны существенно влияют на работу нашего кода на Rust?</p>
<pre><code class="language-rust ignore">impl SerialPort {
    const SER_PORT_SPEED_REG: *mut u32 = 0x4000_1000 as _;

    fn read_speed(
        &amp;self // &lt;------ Это действительно очень важно
    ) -&gt; u32 {
        unsafe {
            ptr::read_volatile(Self::SER_PORT_SPEED_REG)
        }
    }
}</code></pre>
<p>Здесь действуют два важных фактора:</p>
<ul>
<li>Поскольку мы используем синглтон, есть только один способ или место для получения структуры <code>SerialPort</code>.</li>
<li>Чтобы вызвать метод <code>read_speed()</code>, мы должны иметь владение или ссылку на структуру <code>SerialPort</code>.</li>
</ul>
<p>Эти два фактора вместе означают, что доступ к аппаратному обеспечению возможен только в том случае, если мы соответствующим образом удовлетворили проверяющий заимствования, что означает, что у нас никогда не будет нескольких изменяемых ссылок на одно и то же аппаратное обеспечение!</p>
<pre><code class="language-rust ignore">fn main() {
    // Отсутствует ссылка на `self`! Не сработает.
    // SerialPort::read_speed();

    let serial_1 = unsafe { PERIPHERALS.take_serial() };

    // Вы можете читать только то, к чему у вас есть доступ
    let _ = serial_1.read_speed();
}</code></pre>
<h2 id="Относитесь-к-вашему-оборудованию-как-к-данным"><a class="header" href="#Относитесь-к-вашему-оборудованию-как-к-данным">Относитесь к вашему оборудованию как к данным</a></h2>
<p>Кроме того, поскольку некоторые ссылки изменяемые, а некоторые — неизменяемые, становится возможным определить, может ли функция или метод потенциально изменить состояние аппаратного обеспечения. Например,</p>
<p>Это может изменять настройки оборудования:</p>
<pre><code class="language-rust ignore">fn setup_spi_port(
    spi: &amp;mut SpiPort,
    cs_pin: &amp;mut GpioPin
) -&gt; Result&lt;()&gt; {
    // ...
}</code></pre>
<p>А это — нет:</p>
<pre><code class="language-rust ignore">fn read_button(gpio: &amp;GpioPin) -&gt; bool {
    // ...
}</code></pre>
<p>Это позволяет нам обеспечивать, будет ли код изменять аппаратное обеспечение или нет, на этапе <strong>компиляции</strong>, а не во время выполнения. Заметьте, что это обычно работает только в пределах одного приложения, но для систем без операционной системы наше программное обеспечение компилируется в одно приложение, так что это обычно не является ограничением.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Статические-гарантии"><a class="header" href="#Статические-гарантии">Статические гарантии</a></h1>
<p>Система типов Rust предотвращает гонки данных на этапе компиляции (см. трейты <a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a> и <a href="https://doc.rust-lang.org/core/marker/trait.Sync.html"><code>Sync</code></a>). Система типов также может использоваться для проверки других свойств на этапе компиляции, уменьшая необходимость проверок во время выполнения в некоторых случаях.</p>
<p>При применении к встраиваемым программам эти <em>статические проверки</em> могут использоваться, например, для обеспечения правильной конфигурации интерфейсов ввода-вывода. Например, можно разработать API, в котором инициализация последовательного интерфейса возможна только после предварительной настройки пинов, которые будут использоваться этим интерфейсом.</p>
<p>Также можно статически проверять, что такие операции, как установка пина в низкий уровень, могут выполняться только на правильно сконфигурированных периферийных устройствах. Например, попытка изменить состояние выхода пина, настроенного в режиме плавающего входа, вызовет ошибку компиляции.</p>
<p>И, как было показано в предыдущей главе, концепция владения может быть применена к периферийным устройствам, чтобы гарантировать, что только определенные части программы могут изменять периферийное устройство. Этот <em>контроль доступа</em> делает программное обеспечение более предсказуемым по сравнению с альтернативой, когда периферийные устройства рассматриваются как глобальное изменяемое состояние.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Программирование-с-типовыми-состояниями"><a class="header" href="#Программирование-с-типовыми-состояниями">Программирование с типовыми состояниями</a></h1>
<p>Концепция [типовых состояний] описывает кодирование информации о текущем состоянии объекта в тип этого объекта. Хотя это может звучать немного загадочно, если вы использовали <a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">шаблон Builder</a> в Rust, вы уже начали использовать программирование с типовыми состояниями!</p>
<pre><pre class="playground"><code class="language-rust">pub mod foo_module {
    #[derive(Debug)]
    pub struct Foo {
        inner: u32,
    }

    pub struct FooBuilder {
        a: u32,
        b: u32,
    }

    impl FooBuilder {
        pub fn new(starter: u32) -&gt; Self {
            Self {
                a: starter,
                b: starter,
            }
        }

        pub fn double_a(self) -&gt; Self {
            Self {
                a: self.a * 2,
                b: self.b,
            }
        }

        pub fn into_foo(self) -&gt; Foo {
            Foo {
                inner: self.a + self.b,
            }
        }
    }
}

fn main() {
    let x = foo_module::FooBuilder::new(10)
        .double_a()
        .into_foo();

    println!("{:#?}", x);
}</code></pre></pre>
<p>В этом примере нет прямого способа создать объект <code>Foo</code>. Мы должны создать <code>FooBuilder</code> и правильно его инициализировать, прежде чем сможем получить желаемый объект <code>Foo</code>.</p>
<p>Этот минимальный пример кодирует два состояния:</p>
<ul>
<li><code>FooBuilder</code>, который представляет состояние "неконфигурировано" или "конфигурация в процессе".</li>
<li><code>Foo</code>, который представляет состояние "сконфигурировано" или "готово к использованию".</li>
</ul>
<h2 id="Сильная-типизация"><a class="header" href="#Сильная-типизация">Сильная типизация</a></h2>
<p>Поскольку Rust имеет [сильную систему типов], нет простого способа магически создать экземпляр <code>Foo</code> или превратить <code>FooBuilder</code> в <code>Foo</code> без вызова метода <code>into_foo()</code>. Кроме того, вызов метода <code>into_foo()</code> потребляет исходную структуру <code>FooBuilder</code>, что означает, что ее нельзя повторно использовать без создания нового экземпляра.</p>
<p>Это позволяет нам представлять состояния нашей системы как типы и включать необходимые действия для переходов между состояниями в методы, которые обменивают один тип на другой. Создавая <code>FooBuilder</code> и обменивая его на объект <code>Foo</code>, мы проходим через шаги простого конечного автомата.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Периферийные-устройства-как-конечные-автоматы"><a class="header" href="#Периферийные-устройства-как-конечные-автоматы">Периферийные устройства как конечные автоматы</a></h1>
<p>Периферийные устройства микроконтроллера можно рассматривать как набор конечных автоматов. Например, конфигурация упрощенного [GPIO-пина] может быть представлена следующим деревом состояний:</p>
<ul>
<li>Отключен</li>
<li>Включен
<ul>
<li>Настроен как выход
<ul>
<li>Выход: Высокий</li>
<li>Выход: Низкий</li>
</ul>
</li>
<li>Настроен как вход
<ul>
<li>Вход: Высокое сопротивление</li>
<li>Вход: Подтяжка вниз</li>
<li>Вход: Подтяжка вверх</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Если периферийное устройство начинается в режиме <code>Отключен</code>, для перехода в режим <code>Вход: Высокое сопротивление</code> необходимо выполнить следующие шаги:</p>
<ol>
<li>Отключен</li>
<li>Включен</li>
<li>Настроен как вход</li>
<li>Вход: Высокое сопротивление</li>
</ol>
<p>Если мы хотим перейти из <code>Вход: Высокое сопротивление</code> в <code>Вход: Подтяжка вниз</code>, необходимо выполнить следующие шаги:</p>
<ol>
<li>Вход: Высокое сопротивление</li>
<li>Вход: Подтяжка вниз</li>
</ol>
<p>Аналогично, если мы хотим перевести GPIO-пин из режима <code>Вход: Подтяжка вниз</code> в <code>Выход: Высокий</code>, необходимо выполнить следующие шаги:</p>
<ol>
<li>Вход: Подтяжка вниз</li>
<li>Настроен как вход</li>
<li>Настроен как выход</li>
<li>Выход: Высокий</li>
</ol>
<h2 id="Аппаратное-представление"><a class="header" href="#Аппаратное-представление">Аппаратное представление</a></h2>
<p>Обычно перечисленные выше состояния устанавливаются путем записи значений в заданные регистры, отображенные на периферийное устройство GPIO. Давайте определим воображаемый регистр конфигурации GPIO для иллюстрации:</p>
<div class="table-wrapper"><table><thead><tr><th>Имя</th><th>Бит(ы)</th><th>Значение</th><th>Значение</th><th>Примечания</th></tr></thead><tbody>
<tr><td>enable</td><td>0</td><td>0</td><td>отключено</td><td>Отключает GPIO</td></tr>
<tr><td></td><td></td><td>1</td><td>включено</td><td>Включает GPIO</td></tr>
<tr><td>direction</td><td>1</td><td>0</td><td>вход</td><td>Устанавливает направление на вход</td></tr>
<tr><td></td><td></td><td>1</td><td>выход</td><td>Устанавливает направление на выход</td></tr>
<tr><td>input_mode</td><td>2..3</td><td>00</td><td>высокое сопротивление</td><td>Устанавливает вход как высокое сопротивление</td></tr>
<tr><td></td><td></td><td>01</td><td>подтяжка вниз</td><td>Входной пин подтянут вниз</td></tr>
<tr><td></td><td></td><td>10</td><td>подтяжка вверх</td><td>Входной пин подтянут вверх</td></tr>
<tr><td></td><td></td><td>11</td><td>н/д</td><td>Недопустимое состояние. Не устанавливать</td></tr>
<tr><td>output_mode</td><td>4</td><td>0</td><td>установить низкий</td><td>Выходной пин притянут к низкому уровню</td></tr>
<tr><td></td><td></td><td>1</td><td>установить высокий</td><td>Выходной пин притянут к высокому уровню</td></tr>
<tr><td>input_status</td><td>5</td><td>x</td><td>входное значение</td><td>0, если вход &lt; 1.5 В, 1, если вход &gt;= 1.5 В</td></tr>
</tbody></table>
</div>
<p>Мы <em>могли бы</em> предоставить следующую структуру в Rust для управления этим GPIO:</p>
<pre><code class="language-rust ignore">/// Интерфейс GPIO
struct GpioConfig {
    /// Структура конфигурации GPIO, сгенерированная svd2rust
    periph: GPIO_CONFIG,
}

impl GpioConfig {
    pub fn set_enable(&amp;mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&amp;mut self, is_output: bool) {
        self.periph.modify(|_r, w| {
            w.direction().set_bit(is_output)
        });
    }

    pub fn set_input_mode(&amp;mut self, variant: InputMode) {
        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });
    }

    pub fn set_output_mode(&amp;mut self, is_high: bool) {
        self.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });
    }

    pub fn get_input_status(&amp;self) -&gt; bool {
        self.periph.read().input_status().bit_is_set()
    }
}</code></pre>
<p>Однако это позволило бы нам изменять определенные регистры, что не имеет смысла. Например, что произойдет, если мы установим поле <code>output_mode</code>, когда наш GPIO настроен как вход?</p>
<p>В общем, использование этой структуры позволило бы нам достичь состояний, не определенных в нашем конечном автомате выше: например, выход, который подтянут вниз, или вход, который установлен на высокий уровень. Для некоторого оборудования это может не иметь значения. На другом оборудовании это может вызвать неожиданное или неопределенное поведение!</p>
<p>Хотя этот интерфейс удобен для написания, он не обеспечивает соблюдение контрактов проектирования, установленных нашей аппаратной реализацией.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Контракты-проектирования"><a class="header" href="#Контракты-проектирования">Контракты проектирования</a></h1>
<p>В предыдущей главе мы создали интерфейс, который <em>не</em> обеспечивал соблюдение контрактов проектирования. Давайте еще раз посмотрим на наш воображаемый регистр конфигурации GPIO:</p>
<div class="table-wrapper"><table><thead><tr><th>Имя</th><th>Бит(ы)</th><th>Значение</th><th>Значение</th><th>Примечания</th></tr></thead><tbody>
<tr><td>enable</td><td>0</td><td>0</td><td>отключено</td><td>Отключает GPIO</td></tr>
<tr><td></td><td></td><td>1</td><td>включено</td><td>Включает GPIO</td></tr>
<tr><td>direction</td><td>1</td><td>0</td><td>вход</td><td>Устанавливает направление на вход</td></tr>
<tr><td></td><td></td><td>1</td><td>выход</td><td>Устанавливает направление на выход</td></tr>
<tr><td>input_mode</td><td>2..3</td><td>00</td><td>высокое сопротивление</td><td>Устанавливает вход как высокое сопротивление</td></tr>
<tr><td></td><td></td><td>01</td><td>подтяжка вниз</td><td>Входной пин подтянут вниз</td></tr>
<tr><td></td><td></td><td>10</td><td>подтяжка вверх</td><td>Входной пин подтянут вверх</td></tr>
<tr><td></td><td></td><td>11</td><td>н/д</td><td>Недопустимое состояние. Не устанавливать</td></tr>
<tr><td>output_mode</td><td>4</td><td>0</td><td>установить низкий</td><td>Выходной пин притянут к низкому уровню</td></tr>
<tr><td></td><td></td><td>1</td><td>установить высокий</td><td>Выходной пин притянут к высокому уровню</td></tr>
<tr><td>input_status</td><td>5</td><td>x</td><td>входное значение</td><td>0, если вход &lt; 1.5 В, 1, если вход &gt;= 1.5 В</td></tr>
</tbody></table>
</div>
<p>Если вместо этого мы проверяли бы состояние перед использованием базового оборудования, обеспечивая соблюдение наших контрактов проектирования во время выполнения, мы могли бы написать код, который выглядит следующим образом:</p>
<pre><code class="language-rust ignore">/// Интерфейс GPIO
struct GpioConfig {
    /// Структура конфигурации GPIO, сгенерированная svd2rust
    periph: GPIO_CONFIG,
}

impl GpioConfig {
    pub fn set_enable(&amp;mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&amp;mut self, is_output: bool) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
            // Для установки направления пин должен быть включен
            return Err(());
        }

        self.periph.modify(|r, w| {
            w.direction().set_bit(is_output)
        });

        Ok(())
    }

    pub fn set_input_mode(&amp;mut self, variant: InputMode) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
            // Для установки режима входа пин должен быть включен
            return Err(());
        }
        if self.periph.read().direction().bit_is_set() {
            // Для установки режима входа направление должно быть входным
            return Err(());
        }

        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });

        Ok(())
    }

    pub fn set_output_mode(&amp;mut self, is_high: bool) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
            // Для установки режима выхода пин должен быть включен
            return Err(());
        }
        if self.periph.read().direction().bit_is_clear() {
            // Для установки режима выхода направление должно быть выходным
            return Err(());
        }

        self.periph.modify(|_r, w| {
            w.output_mode().set_bit(is_high)
        });

        Ok(())
    }

    pub fn get_input_status(&amp;self) -&gt; bool {
        self.periph.read().input_status().bit_is_set()
    }
}</code></pre>
<p>Теперь давайте используем типовые состояния для кодирования этих состояний в типах, чтобы обеспечить соблюдение контрактов проектирования на этапе компиляции:</p>
<pre><code class="language-rust ignore">struct Enabled;
struct Disabled;
struct Input;
struct Output;
struct HighZ;
struct PulledLow;
struct PulledHigh;

struct GpioConfig&lt;E, D, M&gt; {
    periph: GPIO_CONFIG,
    enabled: E,
    direction: D,
    mode: M,
}

impl GpioConfig&lt;Disabled, Input, HighZ&gt; {
    pub fn new(periph: GPIO_CONFIG) -&gt; Self {
        GpioConfig {
            periph,
            enabled: Disabled,
            direction: Input,
            mode: HighZ,
        }
    }

    pub fn into_enabled_input(self) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
        self.periph.modify(|_r, w| w.enable().set_bit(true));
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }
}

impl GpioConfig&lt;Enabled, Input, HighZ&gt; {
    pub fn bit_is_set(&amp;self) -&gt; bool {
        self.periph.read().input_status().bit_is_set()
    }

    pub fn into_enabled_output(self) -&gt; GpioConfig&lt;Enabled, Output, PulledHigh&gt; {
        self.periph.modify(|_r, w| w.direction().set_bit(true));
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Output,
            mode: PulledHigh,
        }
    }

    pub fn into_input_pull_down(self) -&gt; GpioConfig&lt;Enabled, Input, PulledLow&gt; {
        self.periph.modify(|_r, w| w.input_mode().pull_low());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledLow,
        }
    }

    pub fn into_input_pull_up(self) -&gt; GpioConfig&lt;Enabled, Input, PulledHigh&gt; {
        self.periph.modify(|_r, w| w.input_mode().pull_high());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledHigh,
        }
    }
}

impl GpioConfig&lt;Enabled, Input, PulledLow&gt; {
    pub fn bit_is_set(&amp;self) -&gt; bool {
        self.periph.read().input_status().bit_is_set()
    }

    pub fn into_enabled_output(self) -&gt; GpioConfig&lt;Enabled, Output, PulledHigh&gt; {
        self.periph.modify(|_r, w| w.direction().set_bit(true));
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Output,
            mode: PulledHigh,
        }
    }

    pub fn into_input_pull_up(self) -&gt; GpioConfig&lt;Enabled, Input, PulledHigh&gt; {
        self.periph.modify(|_r, w| w.input_mode().pull_high());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledHigh,
        }
    }
}</code></pre>
<p>Теперь давайте посмотрим, как будет выглядеть код, использующий это:</p>
<pre><code class="language-rust ignore">/*
 * Пример 1: Из неконфигурированного в вход с высоким сопротивлением
 */
let pin: GpioConfig&lt;Disabled, _, _&gt; = get_gpio();

// Нельзя сделать это, пин не включен!
// pin.into_input_pull_down();

// Теперь переводим пин из неконфигурированного во вход с высоким сопротивлением
let input_pin = pin.into_enabled_input();

// Чтение с пина
let pin_state = input_pin.bit_is_set();

// Нельзя сделать это, входные пины не имеют этого интерфейса!
// input_pin.set_bit(true);

/*
 * Пример 2: Из входа с высоким сопротивлением во вход с подтяжкой вниз
 */
let pulled_low = input_pin.into_input_pull_down();
let pin_state = pulled_low.bit_is_set();

/*
 * Пример 3: Из входа с подтяжкой вниз в выход, установленный на высокий уровень
 */
let output_pin = pulled_low.into_enabled_output();
output_pin.set_bit(true);

// Нельзя сделать это, выходные пины не имеют этого интерфейса!
// output_pin.into_input_pull_down();</code></pre>
<p>Этот способ определенно удобен для хранения состояния пина, но почему стоит делать это именно так? Почему это лучше, чем хранить состояние в виде <code>enum</code> внутри структуры <code>GpioConfig</code>?</p>
<h2 id="Функциональная-безопасность-на-этапе-компиляции"><a class="header" href="#Функциональная-безопасность-на-этапе-компиляции">Функциональная безопасность на этапе компиляции</a></h2>
<p>Поскольку мы обеспечиваем соблюдение наших проектных ограничений полностью на этапе компиляции, это не влечет затрат во время выполнения. Невозможно установить режим вывода, когда пин находится в режиме ввода. Вместо этого вы должны пройти через состояния, сначала преобразовав его в выходной пин, а затем установив режим вывода. Благодаря этому отсутствует штраф за проверку текущего состояния перед выполнением функции во время выполнения.</p>
<p>Кроме того, поскольку эти состояния обеспечиваются системой типов, для пользователей этого интерфейса больше нет места для ошибок. Если они попытаются выполнить недопустимый переход состояния, код просто не скомпилируется!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Абстракции-с-нулевой-стоимостью"><a class="header" href="#Абстракции-с-нулевой-стоимостью">Абстракции с нулевой стоимостью</a></h1>
<p>Типовые состояния также являются отличным примером абстракций с нулевой стоимостью — способности переносить определенные поведения на этап компиляции или анализа. Эти типовые состояния не содержат фактических данных и вместо этого используются как маркеры. Поскольку они не содержат данных, у них нет фактического представления в памяти во время выполнения:</p>
<pre><code class="language-rust ignore">use core::mem::size_of;

let _ = size_of::&lt;Enabled&gt;();    // == 0
let _ = size_of::&lt;Input&gt;();      // == 0
let _ = size_of::&lt;PulledHigh&gt;(); // == 0
let _ = size_of::&lt;GpioConfig&lt;Enabled, Input, PulledHigh&gt;&gt;(); // == 0</code></pre>
<h2 id="Типы-нулевого-размера"><a class="header" href="#Типы-нулевого-размера">Типы нулевого размера</a></h2>
<pre><code class="language-rust ignore">struct Enabled;</code></pre>
<p>Структуры, определенные таким образом, называются типами нулевого размера, поскольку они не содержат фактических данных. Хотя эти типы ведут себя как "настоящие" на этапе компиляции — их можно копировать, перемещать, брать ссылки на них и т.д., оптимизатор полностью удаляет их.</p>
<p>В этом фрагменте кода:</p>
<pre><code class="language-rust ignore">pub fn into_input_high_z(self) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
    self.periph.modify(|_r, w| w.input_mode().high_z());
    GpioConfig {
        periph: self.periph,
        enabled: Enabled,
        direction: Input,
        mode: HighZ,
    }
}</code></pre>
<p>Возвращаемая структура <code>GpioConfig</code> никогда не существует во время выполнения. Вызов этой функции обычно сводится к одной инструкции на ассемблере — записи константного значения регистра в адрес регистра. Это означает, что разработанный нами интерфейс типовых состояний является абстракцией с нулевой стоимостью — он не использует больше процессорного времени, оперативной памяти или пространства для кода для отслеживания состояния <code>GpioConfig</code> и преобразуется в тот же машинный код, что и прямой доступ к регистру.</p>
<h2 id="Вложение"><a class="header" href="#Вложение">Вложение</a></h2>
<p>В общем, эти абстракции могут быть вложены так глубоко, как вы пожелаете. Пока все используемые компоненты являются типами нулевого размера, вся структура не будет существовать во время выполнения.</p>
<p>Для сложных или глубоко вложенных структур определение всех возможных комбинаций состояний может быть утомительным. В таких случаях можно использовать макросы для генерации всех реализаций.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Портируемость"><a class="header" href="#Портируемость">Портируемость</a></h1>
<p>Встраиваемые системы делают портируемость очень важной темой: каждый производитель и даже каждая серия от одного производителя предлагает различные периферийные устройства и возможности, а способы взаимодействия с этими периферийными устройствами также различаются.</p>
<p>Общий способ устранения таких различий — использование слоя, называемого уровнем абстракции оборудования или <strong>HAL</strong>.</p>
<blockquote>
<p>Абстракции оборудования — это наборы программных процедур, которые эмулируют некоторые специфические для платформы детали, предоставляя программам прямой доступ к аппаратным ресурсам.</p>
<p>Они часто позволяют программистам писать независимые от устройства высокопроизводительные приложения, предоставляя стандартные вызовы операционной системы к оборудованию.</p>
<p><em>Википедия: <a href="https://en.wikipedia.org/wiki/Hardware_abstraction">Уровень абстракции оборудования</a></em></p>
</blockquote>
<p>Встраиваемые системы в этом отношении немного особенные, поскольку обычно у них нет операционных систем и программного обеспечения, устанавливаемого пользователем, а вместо этого используются образы прошивки, которые компилируются целиком, а также существуют другие ограничения. Таким образом, традиционный подход, определенный Википедией, потенциально может работать, но, вероятно, не является наиболее продуктивным для обеспечения портируемости.</p>
<p>Как это делается в Rust? Встречайте <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong>...</p>
<h2 id="Что-такое-embedded-hal"><a class="header" href="#Что-такое-embedded-hal">Что такое <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>?</a></h2>
<p>Вкратце, это набор трейтов, которые определяют контракты реализации между <strong>реализациями HAL</strong>, <strong>драйверами</strong> и <strong>приложениями (или прошивками)</strong>. Эти контракты включают как возможности (т.е. если трейт реализован для определенного типа, <strong>реализация HAL</strong> предоставляет определенную функциональность), так и методы (т.е. если вы можете создать тип, реализующий трейт, гарантируется наличие методов, указанных в этом трейте).</p>
<p>Типичная структура уровней может выглядеть следующим образом:</p>
<p><img src="portability/../assets/rust_layers.svg" alt="" /></p>
<p>Некоторые из определенных трейтов в <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong> включают:</p>
<ul>
<li>GPIO (пины ввода и вывода)</li>
<li>Последовательная связь</li>
<li>I2C</li>
<li>SPI</li>
<li>Таймеры/обратные отсчеты</li>
<li>Аналогово-цифровое преобразование</li>
</ul>
<p>Основная причина использования трейтов <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong> и крейтов, их реализующих и использующих, — это контроль сложности. Если учесть, что приложение должно реализовать использование периферийного устройства в оборудовании, а также само приложение и, возможно, драйверы для дополнительных аппаратных компонентов, становится понятно, что возможности повторного использования весьма ограничены. Математически, если <strong>M</strong> — это количество реализаций HAL для периферийных устройств, а <strong>N</strong> — количество драйверов, то без использования <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong> сложность реализации может достигать <strong>M×N</strong>. Использование трейтов <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong> снижает сложность реализации до уровня, близкого к <strong>M+N</strong>. Конечно, есть и дополнительные преимущества, такие как меньшее количество проб и ошибок благодаря хорошо определенным и готовым к использованию API.</p>
<h2 id="Пользователи-embedded-hal"><a class="header" href="#Пользователи-embedded-hal">Пользователи <a href="https://crates.io/crates/embedded-hal">embedded-hal</a></a></h2>
<p>Как упомянуто выше, есть три основных пользователя HAL:</p>
<h3 id="Реализация-hal"><a class="header" href="#Реализация-hal">Реализация HAL</a></h3>
<p>Реализация HAL обеспечивает взаимодействие между оборудованием и пользователями трейтов HAL. Типичные реализации состоят из трех частей:</p>
<ul>
<li>Один или несколько типов, специфичных для оборудования</li>
<li>Функции для создания и инициализации таких типов, часто предоставляющие различные параметры конфигурации (скорость, режим работы, используемые пины и т.д.)</li>
<li>Одна или несколько реализаций (<code>impl</code>) трейтов <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong> для этого типа</li>
</ul>
<p>Такая <strong>реализация HAL</strong> может быть представлена в различных вариантах:</p>
<ul>
<li>Через низкоуровневый доступ к оборудованию, например, через регистры</li>
<li>Через операционную систему, например, с использованием <code>sysfs</code> в Linux</li>
<li>Через адаптер, например, заглушки типов для модульного тестирования</li>
<li>Через драйвер для аппаратных адаптеров, например, мультиплексор I2C или расширитель GPIO</li>
</ul>
<h3 id="Драйвер"><a class="header" href="#Драйвер">Драйвер</a></h3>
<p>Драйвер реализует набор пользовательских функций для внутреннего или внешнего компонента, подключенного к периферийному устройству, реализующему трейты <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>. Типичные примеры таких драйверов включают различные датчики (температуры, магнитометр, акселерометр, освещенности), устройства отображения (светодиодные матрицы, ЖК-дисплеи) и исполнительные механизмы (двигатели, передатчики).</p>
<p>Драйвер должен быть инициализирован экземпляром типа, реализующего определенный трейт <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>, что обеспечивается через ограничение трейта, и предоставляет собственный экземпляр типа с пользовательским набором методов, позволяющих взаимодействовать с управляемым устройством.</p>
<h3 id="Приложение"><a class="header" href="#Приложение">Приложение</a></h3>
<p>Приложение объединяет различные части и обеспечивает достижение желаемой функциональности. При переносе между различными системами именно эта часть требует наибольших усилий по адаптации, поскольку приложение должно правильно инициализировать реальное оборудование через реализацию HAL, а инициализация различного оборудования может существенно отличаться. Кроме того, выбор пользователя часто играет большую роль, поскольку компоненты могут быть физически подключены к разным терминалам, шины оборудования иногда требуют внешнего оборудования для соответствия конфигурации, или существуют различные компромиссы в использовании внутренних периферийных устройств (например, доступно несколько таймеров с разными возможностями, или периферийные устройства конфликтуют друг с другом).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Параллелизм"><a class="header" href="#Параллелизм">Параллелизм</a></h1>
<p>Параллелизм возникает, когда разные части вашей программы могут выполняться в разное время или не по порядку. В контексте встраиваемых систем это включает:</p>
<ul>
<li>Обработчики прерываний, которые запускаются при возникновении соответствующего прерывания.</li>
<li>Различные формы многопоточности, когда микропроцессор регулярно переключается между частями вашей программы.</li>
<li>В некоторых системах — многоядерные микропроцессоры, где каждое ядро может независимо выполнять разные части программы одновременно.</li>
</ul>
<p>Поскольку многие программы для встраиваемых систем должны работать с прерываниями, вопросы параллелизма возникают рано или поздно, и именно здесь могут появляться тонкие и сложные ошибки. К счастью, Rust предоставляет ряд абстракций и гарантий безопасности, которые помогают писать корректный код.</p>
<h2 id="Отсутствие-параллелизма"><a class="header" href="#Отсутствие-параллелизма">Отсутствие параллелизма</a></h2>
<p>Самый простой подход к параллелизму в программе для встраиваемых систем — это его полное отсутствие: программа состоит из одного основного цикла, который непрерывно выполняется, и прерывания полностью отсутствуют. Иногда это идеально подходит для решаемой задачи! Обычно такой цикл считывает входные данные, выполняет их обработку и записывает выходные данные.</p>
<pre><code class="language-rust ignore">#[entry]
fn main() {
    let peripherals = setup_peripherals();
    loop {
        let inputs = read_inputs(&amp;peripherals);
        let outputs = process(inputs);
        write_outputs(&amp;peripherals, outputs);
    }
}</code></pre>
<p>Поскольку параллелизм отсутствует, нет необходимости беспокоиться о совместном использовании данных между частями программы или синхронизации доступа к периферийным устройствам. Если такой простой подход подходит для вашей задачи, это может быть отличным решением.</p>
<h2 id="Глобальные-изменяемые-данные"><a class="header" href="#Глобальные-изменяемые-данные">Глобальные изменяемые данные</a></h2>
<p>В отличие от Rust для не-встраиваемых систем, мы обычно не можем позволить себе создавать выделения памяти на куче и передавать ссылки на эти данные в новые потоки. Вместо этого обработчики прерываний могут быть вызваны в любой момент и должны знать, как получить доступ к общей памяти. На самом низком уровне это означает, что у нас должна быть <em>статически выделенная</em> изменяемая память, на которую могут ссылаться как обработчик прерываний, так и основной код.</p>
<p>В Rust такие переменные <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code>static mut</code></a> всегда небезопасны для чтения или записи, так как без особых мер предосторожности можно вызвать состояние гонки, когда доступ к переменной прерывается на полпути прерыванием, которое также обращается к этой переменной.</p>
<p>Для примера, как это поведение может вызывать тонкие ошибки, рассмотрим программу для встраиваемых систем, которая подсчитывает восходящие фронты входного сигнала за каждый односекундный период (счетчик частоты):</p>
<pre><code class="language-rust ignore">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // ОПАСНОСТЬ - На самом деле не безопасно! Может вызвать гонки данных.
            unsafe { COUNTER += 1 };
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}</code></pre>
<p>Каждую секунду прерывание таймера сбрасывает счетчик в 0. Тем временем основной цикл непрерывно измеряет сигнал и увеличивает счетчик при обнаружении перехода с низкого уровня на высокий. Нам пришлось использовать <code>unsafe</code> для доступа к <code>COUNTER</code>, так как это <code>static mut</code>, что означает, что мы обещаем компилятору не вызывать неопределенное поведение. Можете ли вы заметить состояние гонки? Операция увеличения <code>COUNTER</code> <em>не</em> гарантированно атомарна — на большинстве платформ для встраиваемых систем она будет разделена на загрузку, увеличение и сохранение. Если прерывание сработает после загрузки, но до сохранения, сброс в 0 будет проигнорирован после возврата из прерывания — и мы подсчитаем в два раза больше переходов за этот период.</p>
<h2 id="Критические-секции"><a class="header" href="#Критические-секции">Критические секции</a></h2>
<p>Как справиться с гонками данных? Простой подход — использовать <em>критические секции</em>, контекст, в котором прерывания отключены. Обернув доступ к <code>COUNTER</code> в <code>main</code> в критическую секцию, мы можем быть уверены, что прерывание таймера не сработает, пока мы не закончим увеличение <code>COUNTER</code>:</p>
<pre><code class="language-rust ignore">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // Новая критическая секция обеспечивает синхронизированный доступ к COUNTER
            cortex_m::interrupt::free(|_| {
                unsafe { COUNTER += 1 };
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}</code></pre>
<p>В этом примере мы используем <code>cortex_m::interrupt::free</code>, но на других платформах будут аналогичные механизмы для выполнения кода в критической секции. Это эквивалентно отключению прерываний, выполнению кода и последующему их включению.</p>
<p>Обратите внимание, что критическая секция не понадобилась внутри прерывания таймера по двум причинам:</p>
<ul>
<li>Запись 0 в <code>COUNTER</code> не может быть затронута гонкой, так как мы не читаем его.</li>
<li>Прерывание в любом случае не будет прервано основным потоком.</li>
</ul>
<p>Если <code>COUNTER</code> разделяется между несколькими обработчиками прерываний, которые могут <em>вытеснять</em> друг друга, то для каждого из них также может потребоваться критическая секция.</p>
<p>Этот подход решает нашу проблему, но мы по-прежнему пишем много небезопасного кода, о котором нужно тщательно рассуждать, и можем использовать критические секции без необходимости. Каждая критическая секция временно приостанавливает обработку прерываний, что увеличивает размер кода, задержку и джиттер прерываний (прерывания могут обрабатываться дольше, и время до их обработки становится более переменным). Является ли это проблемой, зависит от вашей системы, но в целом мы хотели бы этого избежать.</p>
<p>Важно отметить, что критическая секция гарантирует отсутствие срабатывания прерываний, но не обеспечивает гарантии эксклюзивности в многоядерных системах! Другое ядро может одновременно обращаться к той же памяти, даже без прерываний. Для многоядерных систем потребуются более мощные примитивы синхронизации.</p>
<h2 id="Атомарный-доступ"><a class="header" href="#Атомарный-доступ">Атомарный доступ</a></h2>
<p>На некоторых платформах доступны специальные атомарные инструкции, которые обеспечивают гарантии для операций чтения-модификации-записи. В частности, для Cortex-M: <code>thumbv6</code> (Cortex-M0, Cortex-M0+) поддерживает только атомарные инструкции загрузки и сохранения, тогда как <code>thumbv7</code> (Cortex-M3 и выше) предоставляет полные инструкции Compare and Swap (CAS). Эти инструкции CAS являются альтернативой полному отключению прерываний: мы можем попытаться выполнить увеличение, которое в большинстве случаев успешно, но если оно прерывается, операция увеличения автоматически повторяется. Эти атомарные операции безопасны даже в многоядерных системах.</p>
<pre><code class="language-rust ignore">use core::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // Используем `fetch_add` для атомарного добавления 1 к COUNTER
            COUNTER.fetch_add(1, Ordering::Relaxed);
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // Используем `store` для прямой записи 0 в COUNTER
    COUNTER.store(0, Ordering::Relaxed);
}</code></pre>
<p>Теперь <code>COUNTER</code> — это безопасная <code>static</code> переменная. Благодаря типу <code>AtomicUsize</code> переменная <code>COUNTER</code> может быть безопасно модифицирована как из обработчика прерываний, так и из основного потока без отключения прерываний. Использование <code>Ordering::Relaxed</code> минимизирует накладные расходы на синхронизацию, так как в данном случае не требуется строгая упорядоченность операций между потоками.</p>
<h2 id="Доступ-к-периферийным-устройствам"><a class="header" href="#Доступ-к-периферийным-устройствам">Доступ к периферийным устройствам</a></h2>
<p>В дополнение к общим данным программы часто требуется разделять доступ к периферийным устройствам между основным потоком и обработчиками прерываний. Например, мы можем захотеть считывать входной сигнал с пина GPIO в основном цикле и управлять выходным сигналом с того же порта GPIO в обработчике прерываний.</p>
<p>Типичная проблема в embedded-программах заключается в том, что периферийные устройства являются синглтонами: существует только один экземпляр каждого периферийного устройства. В Rust это часто моделируется с помощью метода <code>take()</code>, который возвращает <code>Option</code> и позволяет захватить периферийное устройство в момент выполнения программы. Чтобы безопасно разделять доступ к такому синглтону, мы можем использовать <code>Mutex</code> и <code>RefCell</code> из библиотеки <code>cortex_m</code> для обеспечения синхронизированного доступа в критических секциях.</p>
<pre><code class="language-rust ignore">use core::cell::RefCell;
use cortex_m::interrupt::{self, Mutex};
use stm32f4::stm32f405;

static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    // Получаем синглтоны периферийных устройств и настраиваем их.
    // Этот пример использует крейт, сгенерированный svd2rust, но
    // большинство крейтов для встраиваемых устройств будут похожими.
    let dp = stm32f405::Peripherals::take().unwrap();
    let gpioa = &amp;dp.GPIOA;

    // Некоторая функция настройки.
    // Предположим, она устанавливает PA0 как вход и PA1 как выход.
    configure_gpio(gpioa);

    // Сохраняем GPIOA в мьютекс, перемещая его.
    interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));
    // Теперь мы больше не можем использовать `gpioa` или `dp.GPIOA`, и должны
    // обращаться к нему через мьютекс.

    // Будьте осторожны, включая прерывание только после настройки MY_GPIO:
    // иначе прерывание может сработать, пока MY_GPIO содержит None,
    // и в текущей реализации (с `unwrap()`) это вызовет панику.
    set_timer_1hz();
    let mut last_state = false;
    loop {
        // Теперь мы будем считывать состояние как цифровой вход через мьютекс
        let state = interrupt::free(|cs| {
            let gpioa = MY_GPIO.borrow(cs).borrow();
            gpioa.as_ref().unwrap().idr.read().idr0().bit_is_set()
        });

        if state &amp;&amp; !last_state {
            // Устанавливаем PA1 в высокий уровень, если обнаружен восходящий фронт на PA0.
            interrupt::free(|cs| {
                let gpioa = MY_GPIO.borrow(cs).borrow();
                gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // В прерывании мы просто сбрасываем PA0.
    interrupt::free(|cs| {
        // Мы можем использовать `unwrap()`, потому что знаем, что прерывание
        // не было включено до установки MY_GPIO; в противном случае нужно
        // обрабатывать возможность значения None.
        let gpioa = MY_GPIO.borrow(cs).borrow();
        gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().clear_bit());
    });
}</code></pre>
<p>Это довольно объемный код, поэтому разберем ключевые моменты.</p>
<pre><code class="language-rust ignore">static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));</code></pre>
<p>Наша общая переменная — это <code>Mutex</code>, содержащий <code>RefCell</code>, который в свою очередь содержит <code>Option</code>. <code>Mutex</code> обеспечивает доступ только в критической секции, что делает переменную безопасной для синхронизации (<code>Sync</code>), хотя обычный <code>RefCell</code> не является <code>Sync</code>. <code>RefCell</code> предоставляет внутреннюю изменяемость через ссылки, что необходимо для работы с <code>GPIOA</code>. <code>Option</code> позволяет инициализировать переменную пустым значением и позже переместить в нее фактическое значение. Мы не можем получить доступ к синглтону периферийного устройства статически, только во время выполнения, поэтому это необходимо.</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));</code></pre>
<p>Внутри критической секции мы вызываем <code>borrow()</code> на мьютексе, что дает нам ссылку на <code>RefCell</code>. Затем мы вызываем <code>replace()</code>, чтобы переместить новое значение в <code>RefCell</code>.</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| {
    let gpioa = MY_GPIO.borrow(cs).borrow();
    gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
});</code></pre>
<p>Наконец, мы используем <code>MY_GPIO</code> безопасно и параллельно. Критическая секция предотвращает срабатывание прерывания, как обычно, и позволяет нам заимствовать мьютекс. <code>RefCell</code> дает нам <code>&amp;Option&lt;GPIOA&gt;</code> и отслеживает, как долго он остается заимствованным — после выхода ссылки из области видимости <code>RefCell</code> обновляется, указывая, что он больше не заимствован.</p>
<p>Поскольку мы не можем переместить <code>GPIOA</code> из <code>&amp;Option</code>, нам нужно преобразовать его в <code>&amp;Option&lt;&amp;GPIOA&gt;</code> с помощью <code>as_ref()</code>, который мы затем можем <code>unwrap()</code>, чтобы получить <code>&amp;GPIOA</code>, позволяющий модифицировать периферийное устройство.</p>
<p>Если требуется изменяемая ссылка на общий ресурс, следует использовать <code>borrow_mut</code> и <code>deref_mut</code>. Следующий код показывает пример с использованием таймера TIM2.</p>
<pre><code class="language-rust ignore">use core::cell::RefCell;
use core::ops::DerefMut;
use cortex_m::interrupt::{self, Mutex};
use cortex_m::asm::wfi;
use stm32f4::stm32f405;

static G_TIM: Mutex&lt;RefCell&lt;Option&lt;Timer&lt;stm32f4::stm32f405::TIM2&gt;&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    let mut cp = cortex_m::Peripherals::take().unwrap();
    let dp = stm32f4::stm32f405::Peripherals::take().unwrap();

    // Некоторая функция настройки таймера.
    // Предположим, она настраивает таймер TIM2, его прерывание NVIC
    // и запускает таймер.
    let tim = configure_timer_interrupt(&amp;mut cp, dp);

    interrupt::free(|cs| {
        G_TIM.borrow(cs).replace(Some(tim));
    });

    loop {
        wfi();
    }
}

#[interrupt]
fn timer() {
    interrupt::free(|cs| {
        if let Some(ref mut tim) = G_TIM.borrow(cs).borrow_mut().deref_mut() {
            tim.start(1.hz());
        }
    });
}</code></pre>
<p>Это безопасно, но немного громоздко. Есть ли другие варианты?</p>
<h2 id="rtic"><a class="header" href="#rtic">RTIC</a></h2>
<p>Одной из альтернатив является фреймворк <a href="https://github.com/rtic-rs/cortex-m-rtic">RTIC</a>, сокращение от Real Time Interrupt-driven Concurrency (Параллелизм, управляемый прерываниями реального времени). Он обеспечивает статические приоритеты и отслеживает доступ к переменным <code>static mut</code> (называемым "ресурсами"), чтобы статически гарантировать безопасный доступ к общим ресурсам без необходимости постоянного входа в критические секции и использования подсчета ссылок (как в <code>RefCell</code>). Это дает ряд преимуществ, таких как отсутствие тупиков и чрезвычайно низкие затраты по времени и памяти.</p>
<p>Фреймворк также включает другие функции, такие как передача сообщений, что уменьшает необходимость в явном общем состоянии, и возможность планировать задачи для выполнения в определенное время, что можно использовать для реализации периодических задач. Подробности см. в <a href="https://rtic.rs">документации</a>.</p>
<h2 id="Операционные-системы-реального-времени"><a class="header" href="#Операционные-системы-реального-времени">Операционные системы реального времени</a></h2>
<p>Еще одна распространенная модель для параллелизма во встраиваемых системах — операционные системы реального времени (RTOS). Хотя в Rust они пока менее исследованы, они широко используются в традиционной разработке для встраиваемых систем. Примеры с открытым исходным кодом включают <a href="https://freertos.org/">FreeRTOS</a> и <a href="http://chibios.org/">ChibiOS</a>. Эти RTOS предоставляют поддержку выполнения нескольких потоков приложения, между которыми процессор переключается, либо когда потоки уступают управление (кооперативная многозадачность), либо на основе регулярного таймера или прерываний (вытесняющая многозадачность). RTOS обычно предоставляют мьютексы и другие примитивы синхронизации и часто взаимодействуют с аппаратными функциями, такими как движки DMA.</p>
<p>На момент написания мало примеров RTOS на Rust, но это интересная область, так что следите за обновлениями!</p>
<h2 id="Многоядерные-системы"><a class="header" href="#Многоядерные-системы">Многоядерные системы</a></h2>
<p>Наличие двух или более ядер в процессорах для встраиваемых систем становится все более распространенным, что добавляет дополнительный уровень сложности к параллелизму. Все примеры с использованием критических секций (включая <code>cortex_m::interrupt::Mutex</code>) предполагают, что единственный другой поток выполнения — это поток прерываний, но в многоядерной системе это уже не так. Вместо этого потребуются примитивы синхронизации, разработанные для многоядерных систем (также называемых SMP, симметричная многопроцессорность).</p>
<p>Они обычно используют атомарные инструкции, которые мы видели ранее, поскольку система обработки гарантирует сохранение атомарности на всех ядрах.</p>
<p>Подробное рассмотрение этих тем пока выходит за рамки этой книги, но общие шаблоны аналогичны случаю с одним ядром.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Коллекции"><a class="header" href="#Коллекции">Коллекции</a></h1>
<p>В конечном итоге вы захотите использовать динамические структуры данных (также известные как коллекции) в вашей программе. <code>std</code> предоставляет набор общих коллекций: <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>, <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>, <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> и т.д. Все коллекции, реализованные в <code>std</code>, используют глобальный динамический распределитель памяти (также известный как куча).</p>
<p>Поскольку <code>core</code> по определению свободен от выделения памяти, эти реализации недоступны там, но их можно найти в крейте <code>alloc</code>, поставляемом с компилятором.</p>
<p>Если вам нужны коллекции, реализация с выделением на куче — не единственный вариант. Вы также можете использовать коллекции с <em>фиксированной емкостью</em>; одна такая реализация находится в крейте <a href="https://crates.io/crates/heapless"><code>heapless</code></a>.</p>
<p>В этом разделе мы рассмотрим и сравним эти две реализации.</p>
<h2 id="Использование-alloc"><a class="header" href="#Использование-alloc">Использование <code>alloc</code></a></h2>
<p>Крейт <code>alloc</code> поставляется со стандартной дистрибуцией Rust. Чтобы импортировать крейт, вы можете напрямую <code>use</code> его <em>без</em> объявления как зависимости в вашем файле <code>Cargo.toml</code>.</p>
<pre><code class="language-rust ignore">#![feature(alloc)]

extern crate alloc;

use alloc::vec::Vec;</code></pre>
<p>Чтобы использовать любую коллекцию, вам сначала нужно использовать атрибут <code>global_allocator</code> для объявления глобального распределителя, который будет использовать ваша программа. Требуется, чтобы выбранный распределитель реализовывал трейт <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a>.</p>
<p>Для полноты и чтобы сделать этот раздел как можно более самодостаточным, мы реализуем простой распределитель указателя смещения и используем его как глобальный распределитель. Однако мы <em>настоятельно</em> рекомендуем использовать проверенный в боях распределитель из crates.io в вашей программе вместо этого распределителя.</p>
<pre><code class="language-rust ignore">// Реализация распределителя указателя смещения

use core::alloc::{GlobalAlloc, Layout};
use core::cell::UnsafeCell;
use core::ptr;

use cortex_m::interrupt;

// Распределитель указателя смещения для *одноядерных* систем
struct BumpPointerAlloc {
    head: UnsafeCell&lt;usize&gt;,
    end: usize,
}

unsafe impl Sync for BumpPointerAlloc {}

unsafe impl GlobalAlloc for BumpPointerAlloc {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        // `interrupt::free` — это критическая секция, которая делает наш распределитель безопасным
        // для использования внутри прерываний
        interrupt::free(|_| {
            let head = self.head.get();
            let size = layout.size();
            let align = layout.align();
            let align_mask = !(align - 1);

            // перемещаем начало к следующей границе выравнивания
            let start = (*head + align - 1) &amp; align_mask;

            if start + size &gt; self.end {
                // нулевой указатель сигнализирует об условии Out Of Memory
                ptr::null_mut()
            } else {
                *head = start + size;
                start as *mut u8
            }
        })
    }

    unsafe fn dealloc(&amp;self, _: *mut u8, _: Layout) {
        // этот распределитель никогда не освобождает память
    }
}

// Объявление глобального распределителя памяти
// ПРИМЕЧАНИЕ: пользователь должен убедиться, что область памяти `[0x2000_0100, 0x2000_0200]`
// не используется другими частями программы
#[global_allocator]
static HEAP: BumpPointerAlloc = BumpPointerAlloc {
    head: UnsafeCell::new(0x2000_0100),
    end: 0x2000_0200,
};</code></pre>
<p>Помимо выбора глобального распределителя, пользователь также должен определить, как обрабатываются ошибки Out Of Memory (OOM), используя <em>нестабильный</em> атрибут <code>alloc_error_handler</code>.</p>
<pre><code class="language-rust ignore">#![feature(alloc_error_handler)]

use cortex_m::asm;

#[alloc_error_handler]
fn on_oom(_layout: Layout) -&gt; ! {
    asm::bkpt();

    loop {}
}</code></pre>
<p>После того, как все это на месте, пользователь наконец-то может использовать коллекции в <code>alloc</code>.</p>
<pre><code class="language-rust ignore">#[entry]
fn main() -&gt; ! {
    let mut xs = Vec::new();

    xs.push(42);
    assert!(xs.pop(), Some(42));

    loop {
        // ..
    }
}</code></pre>
<p>Если вы использовали коллекции в крейте <code>std</code>, то эти будут знакомы, поскольку это точно такая же реализация.</p>
<h2 id="Использование-heapless"><a class="header" href="#Использование-heapless">Использование <code>heapless</code></a></h2>
<p><code>heapless</code> не требует настройки, поскольку его коллекции не зависят от глобального распределителя памяти. Просто <code>use</code> его коллекции и приступайте к ихインスタции:</p>
<pre><code class="language-rust ignore">// версия heapless: v0.4.x
use heapless::Vec;
use heapless::consts::*;

#[entry]
fn main() -&gt; ! {
    let mut xs: Vec&lt;_, U8&gt; = Vec::new();

    xs.push(42).unwrap();
    assert_eq!(xs.pop(), Some(42));
    loop {}
}</code></pre>
<p>Вы заметите две разницы между этими коллекциями и теми, что в <code>alloc</code>.</p>
<p>Во-первых, вы должны объявить заранее емкость коллекции. Коллекции <code>heapless</code> никогда не перераспределяются и имеют фиксированные емкости; эта емкость является частью сигнатуры типа коллекции. В этом случае мы объявили, что <code>xs</code> имеет емкость 8 элементов, то есть вектор может содержать максимум 8 элементов. Это указано <code>U8</code> (см. <a href="https://crates.io/crates/typenum"><code>typenum</code></a>) в сигнатуре типа.</p>
<p>Во-вторых, метод <code>push</code> и многие другие методы возвращают <code>Result</code>. Поскольку коллекции <code>heapless</code> имеют фиксированную емкость, все операции, вставляющие элементы в коллекцию, потенциально могут завершиться неудачей. API отражает эту проблему, возвращая <code>Result</code>, указывающий, удалась ли операция. В отличие от этого, коллекции <code>alloc</code> перераспределят себя на куче, чтобы увеличить емкость.</p>
<p>Начиная с версии v0.4.x, все коллекции <code>heapless</code> хранят все свои элементы inline. Это означает, что операция вроде <code>let x = heapless::Vec::new();</code> выделит коллекцию на стеке, но также возможно выделить коллекцию в <code>static</code> переменной или даже на куче (<code>Box&lt;Vec&lt;_, _&gt;&gt;</code>).</p>
<h2 id="Компромиссы"><a class="header" href="#Компромиссы">Компромиссы</a></h2>
<p>Учитывайте эти аспекты при выборе между коллекциями с выделением на куче, перемещаемыми, и коллекциями с фиксированной емкостью.</p>
<h3 id="out-of-memory-и-обработка-ошибок"><a class="header" href="#out-of-memory-и-обработка-ошибок">Out Of Memory и обработка ошибок</a></h3>
<p>С выделением на куче Out Of Memory всегда возможен и может возникнуть в любом месте, где коллекция может нуждаться в росте: например, все вызовы <code>alloc::Vec.push</code> потенциально могут генерировать условие OOM. Таким образом, некоторые операции могут <em>неявно</em> завершаться неудачей. Некоторые коллекции <code>alloc</code> предоставляют методы <code>try_reserve</code>, которые позволяют проверить потенциальные условия OOM при росте коллекции, но вы должны быть proactive в их использовании.</p>
<p>Если вы исключительно используете коллекции <code>heapless</code> и не используете распределитель памяти ни для чего другого, то условие OOM невозможно. Вместо этого вам придется справляться с исчерпанием емкости коллекций на основе случая за случаем. То есть вам придется справляться со <em>всеми</em> <code>Result</code>, возвращаемыми методами вроде <code>Vec.push</code>.</p>
<p>Сбои OOM могут быть сложнее отлаживать, чем, скажем, <code>unwrap</code> на всех <code>Result</code>, возвращаемых <code>heapless::Vec.push</code>, потому что наблюдаемое место сбоя может <em>не</em> совпадать с местом причины проблемы. Например, даже <code>vec.reserve(1)</code> может вызвать OOM, если распределитель почти исчерпан, потому что какая-то другая коллекция протекала память (утечки памяти возможны в безопасном Rust).</p>
<h3 id="Использование-памяти"><a class="header" href="#Использование-памяти">Использование памяти</a></h3>
<p>Рассуждения об использовании памяти коллекций с выделением на куче сложны, потому что емкость долгоживущих коллекций может изменяться во время выполнения. Некоторые операции могут неявно перераспределять коллекцию, увеличивая использование памяти, и некоторые коллекции предоставляют методы вроде <code>shrink_to_fit</code>, которые потенциально могут уменьшить память, используемую коллекцией — в конечном итоге, распределитель решает, действительно ли сжимать выделение памяти или нет. Кроме того, распределитель может сталкиваться с фрагментацией памяти, что может увеличивать <em>видимое</em> использование памяти.</p>
<p>С другой стороны, если вы исключительно используете коллекции с фиксированной емкостью, храните большинство из них в <code>static</code> переменных и устанавливаете максимальный размер стека вызовов, то линкер обнаружит, если вы пытаетесь использовать больше памяти, чем физически доступно.</p>
<p>Кроме того, коллекции с фиксированной емкостью, выделенные на стеке, будут сообщены флагом <a href="https://doc.rust-lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html"><code>-Z emit-stack-sizes</code></a>, что означает, что инструменты, анализирующие использование стека (вроде <a href="https://crates.io/crates/stack-sizes"><code>stack-sizes</code></a>), включат их в свой анализ.</p>
<p>Однако коллекции с фиксированной емкостью <em>не</em> могут быть уменьшены, что может привести к более низким коэффициентам загрузки (соотношение между размером коллекции и ее емкостью), чем то, чего могут достичь перемещаемые коллекции.</p>
<h3 id="Худшее-время-выполнения-wcet"><a class="header" href="#Худшее-время-выполнения-wcet">Худшее время выполнения (WCET)</a></h3>
<p>Если вы строите приложения, чувствительные ко времени, или приложения реального времени с жесткими требованиями, то вы заботитесь, возможно, сильно, о худшем времени выполнения различных частей вашей программы.</p>
<p>Коллекции <code>alloc</code> могут перераспределяться, так что WCET операций, которые могут расти коллекцию, также будет включать время, затрачиваемое на перераспределение коллекции, которое само зависит от <em>времени выполнения</em> емкости коллекции. Это делает сложным определение WCET, например, операции <code>alloc::Vec.push</code>, поскольку оно зависит как от используемого распределителя, так и от его емкости во время выполнения.</p>
<p>С другой стороны, коллекции с фиксированной емкостью никогда не перераспределяются, так что все операции имеют предсказуемое время выполнения. Например, <code>heapless::Vec.push</code> выполняется за постоянное время.</p>
<h3 id="Простота-использования"><a class="header" href="#Простота-использования">Простота использования</a></h3>
<p><code>alloc</code> требует настройки глобального распределителя, в то время как <code>heapless</code> нет. Однако <code>heapless</code> требует, чтобы вы выбирали емкость каждойインスタциируемой коллекции.</p>
<p>API <code>alloc</code> будет знаком практически каждому разработчику на Rust. API <code>heapless</code> пытается тесно имитировать API <code>alloc</code>, но никогда не будет точно таким же из-за явной обработки ошибок — некоторые разработчики могут считать явную обработку ошибок чрезмерной или слишком громоздкой.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Шаблоны-проектирования"><a class="header" href="#Шаблоны-проектирования">Шаблоны проектирования</a></h1>
<p>Эта глава стремится собрать различные полезные шаблоны проектирования для embedded Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Шаблоны-проектирования-hal"><a class="header" href="#Шаблоны-проектирования-hal">Шаблоны проектирования HAL</a></h1>
<p>Это набор общих и рекомендуемых шаблонов для написания уровней аппаратной абстракции (HAL) для микроконтроллеров на Rust. Эти шаблоны предназначены для использования в дополнение к существующим <a href="https://rust-lang.github.io/api-guidelines/">Рекомендациям по API Rust</a> при написании HAL для микроконтроллеров.</p>
<p><a href="design-patterns/hal/checklist.html">Контрольный список</a></p>
<ul>
<li><a href="design-patterns/hal/naming.html">Именование</a></li>
<li><a href="design-patterns/hal/interoperability.html">Интероперабельность</a></li>
<li><a href="design-patterns/hal/predictability.html">Предсказуемость</a></li>
<li><a href="design-patterns/hal/gpio.html">GPIO</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Контрольный-список-шаблонов-проектирования-hal"><a class="header" href="#Контрольный-список-шаблонов-проектирования-hal">Контрольный список шаблонов проектирования HAL</a></h1>
<ul>
<li><strong>Именование</strong> <em>(крейт соответствует соглашениям об именовании в Rust)</em>
<ul>
<li><input disabled="" type="checkbox"/>
Крейт назван правильно (<a href="design-patterns/hal/naming.html#c-crate-name">C-CRATE-NAME</a>)</li>
</ul>
</li>
<li><strong>Взаимодействие</strong> <em>(крейт хорошо взаимодействует с функциональностью других библиотек)</em>
<ul>
<li><input disabled="" type="checkbox"/>
Типы-обертки предоставляют метод деструктора (<a href="design-patterns/hal/interoperability.html#c-free">C-FREE</a>)</li>
<li><input disabled="" type="checkbox"/>
HAL переэкспортируют свой крейт доступа к регистрам (<a href="design-patterns/hal/interoperability.html#c-reexport-pac">C-REEXPORT-PAC</a>)</li>
<li><input disabled="" type="checkbox"/>
Типы реализуют трейты <code>embedded-hal</code> (<a href="design-patterns/hal/interoperability.html#c-hal-traits">C-HAL-TRAITS</a>)</li>
</ul>
</li>
<li><strong>Предсказуемость</strong> <em>(крейт позволяет писать читаемый код, который работает так, как выглядит)</em>
<ul>
<li><input disabled="" type="checkbox"/>
Используются конструкторы вместо трейтов расширения (<a href="design-patterns/hal/predictability.html#c-ctor">C-CTOR</a>)</li>
</ul>
</li>
<li><strong>Интерфейсы GPIO</strong> <em>(Интерфейсы GPIO следуют общему шаблону)</em>
<ul>
<li><input disabled="" type="checkbox"/>
Типы пинов по умолчанию нулевого размера (<a href="design-patterns/hal/gpio.html#c-zst-pin">C-ZST-PIN</a>)</li>
<li><input disabled="" type="checkbox"/>
Типы пинов предоставляют методы для стирания пина и порта (<a href="design-patterns/hal/gpio.html#c-erased-pin">C-ERASED-PIN</a>)</li>
<li><input disabled="" type="checkbox"/>
Состояние пина должно быть закодировано как параметры типа (<a href="design-patterns/hal/gpio.html#c-pin-state">C-PIN-STATE</a>)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Именование"><a class="header" href="#Именование">Именование</a></h1>
<p><a id="c-crate-name"></a></p>
<h2 id="Крейт-назван-корректно-c-crate-name"><a class="header" href="#Крейт-назван-корректно-c-crate-name">Крейт назван корректно (C-CRATE-NAME)</a></h2>
<p>Крейты HAL должны быть названы по имени микросхемы или семейства микросхем, которые они поддерживают. Их имя должно заканчиваться на <code>-hal</code>, чтобы отличать их от крейтов доступа к регистрам. В имени не должны использоваться подчеркивания (вместо них используйте дефисы).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Интероперабельность"><a class="header" href="#Интероперабельность">Интероперабельность</a></h1>
<p><a id="c-free"></a></p>
<h2 id="Типы-обертки-предоставляют-метод-деструктора-c-free"><a class="header" href="#Типы-обертки-предоставляют-метод-деструктора-c-free">Типы-обертки предоставляют метод деструктора (C-FREE)</a></h2>
<p>Любой тип-обертка, не являющийся <code>Copy</code>, предоставляемый HAL, должен иметь метод <code>free</code>, который потребляет обертку и возвращает исходное периферийное устройство (и, возможно, другие объекты), из которого она была создана.</p>
<p>Метод должен при необходимости выключать и сбрасывать периферийное устройство. Вызов <code>new</code> с исходным периферийным устройством, возвращенным из <code>free</code>, не должен завершаться с ошибкой из-за неожиданного состояния периферийного устройства.</p>
<p>Если тип HAL требует создания других объектов, не являющихся <code>Copy</code> (например, пинов ввода-вывода), такие объекты также должны быть освобождены и возвращены методом <code>free</code>. В этом случае <code>free</code> должен возвращать кортеж.</p>
<p>Пример:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct TIMER0;
</span>pub struct Timer(TIMER0);

impl Timer {
    pub fn new(periph: TIMER0) -&gt; Self {
        Self(periph)
    }

    pub fn free(self) -&gt; TIMER0 {
        self.0
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-reexport-pac"></a></p>
<h2 id="hal-переэкспортирует-свой-крейт-доступа-к-регистрам-c-reexport-pac"><a class="header" href="#hal-переэкспортирует-свой-крейт-доступа-к-регистрам-c-reexport-pac">HAL переэкспортирует свой крейт доступа к регистрам (C-REEXPORT-PAC)</a></h2>
<p>HAL могут быть написаны на основе PAC, сгенерированных <a href="https://github.com/rust-embedded/svd2rust">svd2rust</a>, или на основе других крейтов, предоставляющих прямой доступ к регистрам. HAL всегда должны переэкспортировать крейт доступа к регистрам, на котором они основаны, в корне своего крейта.</p>
<p>PAC должен быть переэкспортирован под именем <code>pac</code>, независимо от фактического имени крейта, поскольку имя HAL уже должно ясно указывать, какой PAC используется.</p>
<p><a id="c-hal-traits"></a></p>
<h2 id="Типы-реализуют-трейты-embedded-hal-c-hal-traits"><a class="header" href="#Типы-реализуют-трейты-embedded-hal-c-hal-traits">Типы реализуют трейты <code>embedded-hal</code> (C-HAL-TRAITS)</a></h2>
<p>Типы, предоставляемые HAL, должны реализовывать все применимые трейты, предоставляемые крейтом <a href="https://github.com/rust-embedded/embedded-hal"><code>embedded-hal</code></a>.</p>
<p>Один и тот же тип может реализовывать несколько трейтов.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Предсказуемость"><a class="header" href="#Предсказуемость">Предсказуемость</a></h1>
<p><a id="c-ctor"></a></p>
<h2 id="Используются-конструкторы-вместо-трейтов-расширений-c-ctor"><a class="header" href="#Используются-конструкторы-вместо-трейтов-расширений-c-ctor">Используются конструкторы вместо трейтов-расширений (C-CTOR)</a></h2>
<p>Все периферийные устройства, для которых HAL добавляет функциональность, должны быть обернуты в новый тип, даже если для этой функциональности не требуются дополнительные поля.</p>
<p>Следует избегать реализации трейтов-расширений для исходного периферийного устройства.</p>
<p><a id="c-inline"></a></p>
<h2 id="Методы-помечены-inline-там-где-это-уместно-c-inline"><a class="header" href="#Методы-помечены-inline-там-где-это-уместно-c-inline">Методы помечены <code>#[inline]</code> там, где это уместно (C-INLINE)</a></h2>
<p>Компилятор Rust по умолчанию не выполняет полное встраивание через границы крейтов. Поскольку приложения для встраиваемых систем чувствительны к неожиданным увеличениям размера кода, <code>#[inline]</code> следует использовать для направления компилятора следующим образом:</p>
<ul>
<li>Все "маленькие" функции должны быть помечены <code>#[inline]</code>. Что считать "маленьким" — субъективно, но, как правило, все функции, которые компилируются в последовательности инструкций с однозначным количеством, считаются маленькими.</li>
<li>Функции, которые с высокой вероятностью принимают константные значения в качестве параметров, должны быть помечены <code>#[inline]</code>. Это позволяет компилятору вычислять даже сложную логику инициализации во время компиляции, если входные данные функции известны.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Рекомендации-для-интерфейсов-gpio"><a class="header" href="#Рекомендации-для-интерфейсов-gpio">Рекомендации для интерфейсов GPIO</a></h1>
<p><a id="c-zst-pin"></a></p>
<h2 id="Типы-пинов-по-умолчанию-имеют-нулевой-размер-c-zst-pin"><a class="header" href="#Типы-пинов-по-умолчанию-имеют-нулевой-размер-c-zst-pin">Типы пинов по умолчанию имеют нулевой размер (C-ZST-PIN)</a></h2>
<p>Интерфейсы GPIO, предоставляемые HAL, должны предоставлять выделенные типы нулевого размера для каждого пина на каждом интерфейсе или порте, обеспечивая абстракцию GPIO с нулевыми накладными расходами, когда все назначения пинов статически известны.</p>
<p>Каждый интерфейс или порт GPIO должен реализовывать метод <code>split</code>, возвращающий структуру со всеми пинами.</p>
<p>Пример:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PA0;
pub struct PA1;
// ...

pub struct PortA;

impl PortA {
    pub fn split(self) -&gt; PortAPins {
        PortAPins {
            pa0: PA0,
            pa1: PA1,
            // ...
        }
    }
}

pub struct PortAPins {
    pub pa0: PA0,
    pub pa1: PA1,
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-erased-pin"></a></p>
<h2 id="Типы-пинов-предоставляют-методы-для-стирания-пина-и-порта-c-erased-pin"><a class="header" href="#Типы-пинов-предоставляют-методы-для-стирания-пина-и-порта-c-erased-pin">Типы пинов предоставляют методы для стирания пина и порта (C-ERASED-PIN)</a></h2>
<p>Пины должны предоставлять методы стирания типов, которые переводят их свойства из времени компиляции во время выполнения, обеспечивая большую гибкость в приложениях.</p>
<p>Пример:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Порт A, пин 0.
pub struct PA0;

impl PA0 {
    pub fn erase_pin(self) -&gt; PA {
        PA { pin: 0 }
    }
}

/// Пин на порте A.
pub struct PA {
    /// Номер пина.
    pin: u8,
}

impl PA {
    pub fn erase_port(self) -&gt; Pin {
        Pin {
            port: Port::A,
            pin: self.pin,
        }
    }
}

pub struct Pin {
    port: Port,
    pin: u8,
    // (эти поля могут быть упакованы для уменьшения занимаемой памяти)
}

enum Port {
    A,
    B,
    C,
    D,
}
<span class="boring">}</span></code></pre></pre>
<p><a id="c-pin-state"></a></p>
<h2 id="Состояние-пина-должно-быть-закодировано-в-параметрах-типа-c-pin-state"><a class="header" href="#Состояние-пина-должно-быть-закодировано-в-параметрах-типа-c-pin-state">Состояние пина должно быть закодировано в параметрах типа (C-PIN-STATE)</a></h2>
<p>Пины могут быть настроены как вход или выход с различными характеристиками в зависимости от микросхемы или семейства. Это состояние должно быть закодировано в системе типов, чтобы предотвратить использование пинов в некорректных состояниях.</p>
<p>Дополнительное, специфичное для микросхемы состояние (например, сила тока) также может быть закодировано таким образом с использованием дополнительных параметров типа.</p>
<p>Методы для изменения состояния пина должны предоставляться как <code>into_input</code> и <code>into_output</code>.</p>
<p>Кроме того, должны быть предоставлены методы <code>with_input_state</code> и <code>with_output_state</code>, которые временно изменяют состояние пина.</p>
<p>Пример:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::marker::PhantomData;
</span>mod sealed {
    pub trait Sealed {}
}

pub trait PinState: sealed::Sealed {}
pub trait OutputState: sealed::Sealed {}
pub trait InputState: sealed::Sealed {
    // ...
}

pub struct Output&lt;S: OutputState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: OutputState&gt; PinState for Output&lt;S&gt; {}
impl&lt;S: OutputState&gt; sealed::Sealed for Output&lt;S&gt; {}

pub struct PushPull;
pub struct OpenDrain;

impl OutputState for PushPull {}
impl OutputState for OpenDrain {}
impl sealed::Sealed for PushPull {}
impl sealed::Sealed for OpenDrain {}

pub struct Input&lt;S: InputState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: InputState&gt; PinState for Input&lt;S&gt; {}
impl&lt;S: InputState&gt; sealed::Sealed for Input&lt;S&gt; {}

pub struct Floating;
pub struct PullUp;
pub struct PullDown;

impl InputState for Floating {}
impl InputState for PullUp {}
impl InputState for PullDown {}
impl sealed::Sealed for Floating {}
impl sealed::Sealed for PullUp {}
impl sealed::Sealed for PullDown {}

pub struct PA1&lt;S: PinState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: PinState&gt; PA1&lt;S&gt; {
    pub fn into_input&lt;N: InputState&gt;(self, input: N) -&gt; PA1&lt;Input&lt;N&gt;&gt; {
        todo!()
    }

    pub fn into_output&lt;N: OutputState&gt;(self, output: N) -&gt; PA1&lt;Output&lt;N&gt;&gt; {
        todo!()
    }

    pub fn with_input_state&lt;N: InputState, R&gt;(
        &amp;mut self,
        input: N,
        f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
    ) -&gt; R {
        todo!()
    }

    pub fn with_output_state&lt;N: OutputState, R&gt;(
        &amp;mut self,
        output: N,
        f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
    ) -&gt; R {
        todo!()
    }
}

// То же самое для `PA` и `Pin`, и других типов пинов.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Советы-для-разработчиков-на-embedded-c"><a class="header" href="#Советы-для-разработчиков-на-embedded-c">Советы для разработчиков на embedded C</a></h1>
<p>Эта глава собирает различные советы, которые могут быть полезны опытным разработчикам на embedded C, желающим начать писать на Rust. Особое внимание будет уделено тому, как вещи, к которым вы уже привыкли в C, отличаются в Rust.</p>
<h2 id="Препроцессор"><a class="header" href="#Препроцессор">Препроцессор</a></h2>
<p>В embedded C очень распространено использование препроцессора для различных целей, таких как:</p>
<ul>
<li>Выбор блоков кода во время компиляции с помощью <code>#ifdef</code></li>
<li>Размеры массивов и вычисления во время компиляции</li>
<li>Макросы для упрощения общих шаблонов (чтобы избежать накладных расходов на вызов функций)</li>
</ul>
<p>В Rust нет препроцессора, поэтому многие из этих случаев использования решаются по-другому. В остальной части этого раздела мы рассмотрим различные альтернативы использованию препроцессора.</p>
<h3 id="Выбор-кода-во-время-компиляции"><a class="header" href="#Выбор-кода-во-время-компиляции">Выбор кода во время компиляции</a></h3>
<p>Наиболее близким аналогом <code>#ifdef ... #endif</code> в Rust являются <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">функции Cargo</a>. Они немного более формальны, чем препроцессор C: все возможные функции явно перечислены для каждого крейта и могут быть либо включены, либо выключены. Функции включаются при перечислении крейта как зависимости и являются аддитивными: если любой крейт в вашем дереве зависимостей включает функцию для другого крейта, эта функция будет включена для всех пользователей этого крейта.</p>
<p>Например, у вас может быть крейт, предоставляющий библиотеку примитивов обработки сигналов. Каждый из них может требовать дополнительного времени на компиляцию или объявлять большую таблицу констант, которую вы хотите избежать. Вы можете объявить функцию Cargo для каждого компонента в вашем <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
FIR = []
IIR = []
</code></pre>
<p>Затем в вашем коде используйте <code>#[cfg(feature="FIR")]</code> для управления тем, что включается.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// В вашем lib.rs верхнего уровня

#[cfg(feature="FIR")]
pub mod fir;

#[cfg(feature="IIR")]
pub mod iir;
<span class="boring">}</span></code></pre></pre>
<p>Аналогично вы можете включать блоки кода только если функция <em>не</em> включена или если любая комбинация функций включена или не включена.</p>
<p>Кроме того, Rust предоставляет ряд автоматически устанавливаемых условий, которые вы можете использовать, таких как <code>target_arch</code> для выбора разного кода в зависимости от архитектуры. Для полного описания поддержки условной компиляции обратитесь к главе <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">условная компиляция</a> справочника Rust.</p>
<p>Условная компиляция применяется только к следующему утверждению или блоку. Если блок не может быть использован в текущей области видимости, то атрибут <code>cfg</code> нужно использовать несколько раз. Стоит отметить, что в большинстве случаев лучше просто включить весь код и позволить компилятору удалить неиспользуемый код при оптимизации: это проще для вас и ваших пользователей, и в общем случае компилятор хорошо справляется с удалением неиспользуемого кода.</p>
<h3 id="Размеры-и-вычисления-во-время-компиляции"><a class="header" href="#Размеры-и-вычисления-во-время-компиляции">Размеры и вычисления во время компиляции</a></h3>
<p>Rust поддерживает <code>const fn</code>, функции, которые гарантированно вычисляемы во время компиляции и поэтому могут использоваться там, где требуются константы, например, в размере массивов. Это можно использовать вместе с функциями, упомянутыми выше, например:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn array_size() -&gt; usize {
    #[cfg(feature="use_more_ram")]
    { 1024 }
    #[cfg(not(feature="use_more_ram"))]
    { 128 }
}

static BUF: [u32; array_size()] = [0u32; array_size()];
<span class="boring">}</span></code></pre></pre>
<p>Это новинка в стабильном Rust с версии 1.31, поэтому документация все еще скудна. Функциональность, доступная для <code>const fn</code>, также очень ограничена на момент написания; в будущих релизах Rust ожидается расширение того, что разрешено в <code>const fn</code>.</p>
<h3 id="Макросы"><a class="header" href="#Макросы">Макросы</a></h3>
<p>Rust предоставляет чрезвычайно мощную <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">систему макросов</a>. В то время как препроцессор C работает почти напрямую с текстом вашего исходного кода, система макросов Rust работает на более высоком уровне. Существуют два вида макросов Rust: <em>макросы по примеру</em> и <em>процедурные макросы</em>. Первые проще и наиболее распространены; они выглядят как вызовы функций и могут расширяться в полное выражение, утверждение, элемент или шаблон. Процедурные макросы более сложны, но позволяют чрезвычайно мощные дополнения к языку Rust: они могут преобразовывать произвольный синтаксис Rust в новый синтаксис Rust.</p>
<p>В общем, там, где вы могли бы использовать макрос препроцессора C, вы, вероятно, хотите посмотреть, может ли макрос по примеру справиться с задачей. Они могут быть определены в вашем крейте и легко использоваться вашим крейтом или экспортироваться для других пользователей. Имейте в виду, что поскольку они должны расширяться в полные выражения, утверждения, элементы или шаблоны, некоторые случаи использования макросов препроцессора C не будут работать, например, макрос, который расширяется в часть имени переменной или неполный набор элементов в списке.</p>
<p>Как и с функциями Cargo, стоит подумать, нужен ли вам макрос вообще. Во многих случаях обычная функция проще для понимания и будет встроена в тот же код, что и макрос. Атрибуты <code>#[inline]</code> и <code>#[inline(always)]</code> <a href="https://doc.rust-lang.org/reference/attributes.html#inline-attribute">attributes</a> дают вам дополнительный контроль над этим процессом, хотя здесь тоже следует проявлять осторожность — компилятор автоматически встраивает функции из того же крейта, где это уместно, так что принуждение к этому неуместно может привести к снижению производительности.</p>
<p>Объяснение всей системы макросов Rust выходит за рамки этой страницы советов, поэтому рекомендуется обратиться к документации Rust за полными деталями.</p>
<h2 id="Система-сборки"><a class="header" href="#Система-сборки">Система сборки</a></h2>
<p>Большинство крейтов Rust собираются с использованием Cargo (хотя это не обязательно). Это решает многие сложные проблемы традиционных систем сборки. Однако вы можете захотеть настроить процесс сборки. Cargo предоставляет <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">скрипты <code>build.rs</code></a> для этой цели. Это скрипты на Rust, которые могут взаимодействовать с системой сборки Cargo по мере необходимости.</p>
<p>Общие случаи использования скриптов сборки включают:</p>
<ul>
<li>предоставление информации во время сборки, например, статическое встраивание даты сборки или хэша коммита Git в исполняемый файл</li>
<li>генерация скриптов линковки во время сборки в зависимости от выбранных функций или другой логики</li>
<li>изменение конфигурации сборки Cargo</li>
<li>добавление дополнительных статических библиотек для линковки</li>
</ul>
<p>На данный момент нет поддержки скриптов после сборки, которые вы могли бы традиционно использовать для задач, таких как автоматическая генерация бинарных файлов из объектов сборки или печать информации о сборке.</p>
<h3 id="Кросс-компиляция"><a class="header" href="#Кросс-компиляция">Кросс-компиляция</a></h3>
<p>Использование Cargo для системы сборки также упрощает кросс-компиляцию. В большинстве случаев достаточно указать Cargo <code>--target thumbv6m-none-eabi</code> и найти подходящий исполняемый файл в <code>target/thumbv6m-none-eabi/debug/myapp</code>.</p>
<p>Для платформ, не поддерживаемых Rust нативно, вам нужно будет собрать <code>libcore</code> для этой цели самостоятельно. На таких платформах можно использовать <a href="https://github.com/japaric/xargo">Xargo</a> как замену Cargo, который автоматически собирает <code>libcore</code> для вас.</p>
<h2 id="Итераторы-против-доступа-к-массиву"><a class="header" href="#Итераторы-против-доступа-к-массиву">Итераторы против доступа к массиву</a></h2>
<p>В C вы, вероятно, привыкли обращаться к массивам напрямую по индексу:</p>
<pre><code class="language-c">int16_t arr[16];
int i;
for(i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); i++) {
    arr[i] = i;
}
</code></pre>
<p>В Rust предпочтительным подходом является использование итераторов, которые часто более безопасны и выразительны. Например:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut arr = [0i16; 16];
for (i, v) in arr.iter_mut().enumerate() {
    *v = i as i16;
}
<span class="boring">}</span></code></pre></pre>
<p>Итераторы в Rust позволяют избежать ошибок, связанных с выходом за границы массива, и предоставляют мощные методы для обработки данных. Однако в контексте embedded, где производительность критична, иногда может потребоваться прямой доступ к массиву, как в C. В таких случаях вы можете использовать индексацию, но будьте осторожны с проверкой границ:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut arr = [0i16; 16];
for i in 0..arr.len() {
    arr[i] = i as i16;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="Указатели"><a class="header" href="#Указатели">Указатели</a></h2>
<p>В C указатели — это фундаментальная часть языка, используемая для прямого доступа к памяти, особенно в embedded-разработке. В Rust указатели существуют, но их использование ограничено из-за системы владения и заимствования. В Rust есть два типа сырых указателей: <code>*const T</code> и <code>*mut T</code>. Они похожи на указатели в C в том смысле, что их можно разыменовать для доступа к базовым значениям, но они являются ключевой частью системы владения Rust: Rust строго обеспечивает, что у вас может быть только одна изменяемая ссылка <em>или</em> несколько неизменяемых ссылок на одно и то же значение в любой момент времени.</p>
<p>На практике это означает, что вы должны быть более осторожны с тем, нужен ли вам изменяемый доступ к данным: если в C по умолчанию все изменяемо и вы должны явно указывать <code>const</code>, в Rust наоборот.</p>
<p>Одна ситуация, когда вы все еще можете использовать сырые указатели, — это прямое взаимодействие с аппаратным обеспечением (например, запись указателя на буфер в регистр DMA), и они также используются под капотом во всех крейтах доступа к периферийным устройствам, чтобы позволить вам читать и записывать регистры с отображением в память.</p>
<h2 id="Волатильный-доступ"><a class="header" href="#Волатильный-доступ">Волатильный доступ</a></h2>
<p>В C отдельные переменные могут быть помечены как <code>volatile</code>, что указывает компилятору, что значение переменной может измениться между обращениями. Волатильные переменные обычно используются в контексте embedded для регистров с отображением в память.</p>
<p>В Rust вместо пометки переменной как <code>volatile</code> мы используем специальные методы для выполнения волатильного доступа: <a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code>core::ptr::read_volatile</code></a> и <a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code>core::ptr::write_volatile</code></a>. Эти методы принимают <code>*const T</code> или <code>*mut T</code> (<em>сырые указатели</em>, как обсуждалось выше) и выполняют волатильное чтение или запись.</p>
<p>Например, в C вы могли бы написать:</p>
<pre><code class="language-c">volatile bool signalled = false;

void ISR() {
    // Сигнализируем, что прерывание произошло
    signalled = true;
}

void driver() {
    while(true) {
        // Спим до сигнала
        while(!signalled) { WFI(); }
        // Сбрасываем индикатор сигнала
        signalled = false;
        // Выполняем задачу, ожидающую прерывания
        run_task();
    }
}
</code></pre>
<p>Эквивалент в Rust использовал бы волатильные методы для каждого доступа:</p>
<pre><code class="language-rust ignore">static mut SIGNALLED: bool = false;

#[interrupt]
fn ISR() {
    // Сигнализируем, что прерывание произошло
    // (В реальном коде следует рассмотреть примитив более высокого уровня,
    // например, атомарный тип).
    unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, true) };
}

fn driver() {
    loop {
        // Спим до сигнала
        while unsafe { !core::ptr::read_volatile(&amp;SIGNALLED) } {}
        // Сбрасываем индикатор сигнала
        unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, false) };
        // Выполняем задачу, ожидающую прерывания
        run_task();
    }
}</code></pre>
<p>Несколько моментов, которые стоит отметить в примере кода:</p>
<ul>
<li>Мы можем передать <code>&amp;mut SIGNALLED</code> в функцию, требующую <code>*mut T</code>, поскольку <code>&amp;mut T</code> автоматически преобразуется в <code>*mut T</code> (и то же самое для <code>*const T</code>)</li>
<li>Нам нужны блоки <code>unsafe</code> для методов <code>read_volatile</code>/<code>write_volatile</code>, поскольку это небезопасные функции. Ответственность за обеспечение безопасного использования лежит на программисте: подробности см. в документации методов.</li>
</ul>
<p>Прямое использование этих функций в вашем коде редко требуется, так как они обычно обрабатываются библиотеками более высокого уровня. Для регистров с отображением в память крейты доступа к периферийным устройствам автоматически реализуют волатильный доступ, в то время как для примитивов параллелизма доступны лучшие абстракции (см. главу <a href="c-tips/../concurrency/index.html">Параллелизм</a>).</p>
<h2 id="Упакованные-и-выровненные-типы"><a class="header" href="#Упакованные-и-выровненные-типы">Упакованные и выровненные типы</a></h2>
<p>В embedded C часто указывают компилятору, что переменная должна иметь определенное выравнивание или структура должна быть упакована, а не выровнена, обычно для соответствия требованиям аппаратного обеспечения или протокола.</p>
<p>В Rust это контролируется атрибутом <code>repr</code> для структуры или объединения. Представление по умолчанию не предоставляет гарантий компоновки, поэтому его не следует использовать для кода, взаимодействующего с аппаратным обеспечением или C. Компилятор может переупорядочить члены структуры или вставить заполнение, и поведение может измениться в будущих версиях Rust.</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2
// Обратите внимание, что порядок изменен на x, z, y для улучшения упаковки.</code></pre></pre>
<p>Чтобы обеспечить компоновку, совместимую с C, используйте <code>repr(C)</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64
// Порядок сохранен, и компоновка не изменится со временем.
// `z` выровнен по двум байтам, поэтому между `y` и `z` существует байт заполнения.</code></pre></pre>
<p>Для обеспечения упакованного представления используйте <code>repr(packed)</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(packed)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    // Ссылки всегда должны быть выровнены, поэтому для проверки адресов полей структуры
    // мы используем `std::ptr::addr_of!()` для получения сырого указателя
    // вместо простого вывода `&amp;v.x`.
    let px = std::ptr::addr_of!(v.x);
    let py = std::ptr::addr_of!(v.y);
    let pz = std::ptr::addr_of!(v.z);
    println!("{:p} {:p} {:p}", px, py, pz);
}

// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493
// Между `y` и `z` не вставлено заполнение, поэтому теперь `z` не выровнен.</code></pre></pre>
<p>Обратите внимание, что использование <code>repr(packed)</code> также устанавливает выравнивание типа в <code>1</code>.</p>
<p>Наконец, чтобы указать конкретное выравнивание, используйте <code>repr(align(n))</code>, где <code>n</code> — это количество байтов для выравнивания (и должно быть степенью двойки):</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
#[repr(align(4096))]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    let u = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
    println!("{:p} {:p} {:p}", &amp;u.x, &amp;u.y, &amp;u.z);
}

// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004
// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004
// Два экземпляра `u` и `v` размещены с выравниванием по 4096 байтам,
// о чем свидетельствует `000` в конце их адресов.</code></pre></pre>
<p>Обратите внимание, что мы можем комбинировать <code>repr(C)</code> с <code>repr(align(n))</code> для получения выровненной и совместимой с C компоновки. Нельзя комбинировать <code>repr(align(n))</code> с <code>repr(packed)</code>, поскольку <code>repr(packed)</code> устанавливает выравнивание в <code>1</code>. Также недопустимо, чтобы тип <code>repr(packed)</code> содержал тип <code>repr(align(n))</code>.</p>
<p>Для дополнительной информации о компоновке типов обратитесь к главе <a href="https://doc.rust-lang.org/reference/type-layout.html">компоновка типов</a> справочника Rust.</p>
<h2 id="Другие-ресурсы-1"><a class="header" href="#Другие-ресурсы-1">Другие ресурсы</a></h2>
<ul>
<li>В этой книге:
<ul>
<li><a href="c-tips/../interoperability/c-with-rust.html">Немного C с вашим Rust</a></li>
<li><a href="c-tips/../interoperability/rust-with-c.html">Немного Rust с вашим C</a></li>
</ul>
</li>
<li><a href="https://docs.rust-embedded.org/faq.html">Часто задаваемые вопросы по Rust Embedded</a></li>
<li><a href="http://blahg.josefsipek.net/?p=580">Указатели Rust для программистов на C</a></li>
<li><a href="https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md">Я использовал указатели — что теперь?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Интероперабельность-1"><a class="header" href="#Интероперабельность-1">Интероперабельность</a></h1>
<p>Интероперабельность между кодом на Rust и C всегда зависит от преобразования данных между двумя языками. Для этой цели в <code>stdlib</code> есть специальный модуль, называемый <a href="https://doc.rust-lang.org/std/ffi/index.html"><code>std::ffi</code></a>.</p>
<p><code>std::ffi</code> предоставляет определения типов для примитивов C, таких как <code>char</code>, <code>int</code> и <code>long</code>. Также он предоставляет утилиты для преобразования более сложных типов, таких как строки, отображая как <code>&amp;str</code>, так и <code>String</code> на типы C, которые легче и безопаснее обрабатывать.</p>
<p>Начиная с Rust 1.30, функциональность <code>std::ffi</code> доступна либо в <code>core::ffi</code>, либо в <code>alloc::ffi</code>, в зависимости от того, связано ли это с выделением памяти. Крейты <a href="https://crates.io/crates/cty"><code>cty</code></a> и <a href="https://crates.io/crates/cstr_core"><code>cstr_core</code></a> также предлагают аналогичные функциональности.</p>
<div class="table-wrapper"><table><thead><tr><th>Тип Rust</th><th>Промежуточный</th><th>Тип C</th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>CString</code></td><td><code>char *</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>CStr</code></td><td><code>const char *</code></td></tr>
<tr><td><code>()</code></td><td><code>c_void</code></td><td><code>void</code></td></tr>
<tr><td><code>u32</code> или <code>u64</code></td><td><code>c_uint</code></td><td><code>unsigned int</code></td></tr>
<tr><td>и т.д.</td><td>...</td><td>...</td></tr>
</tbody></table>
</div>
<p>Значение типа-примитива C можно использовать как соответствующий тип Rust и наоборот, поскольку первый является просто псевдонимом второго. Например, следующий код компилируется на платформах, где <code>unsigned int</code> имеет длину 32 бита:</p>
<pre><code class="language-rust ignore">fn foo(num: u32) {
    let c_num: c_uint = num;
    let r_num: u32 = c_num;
}</code></pre>
<h2 id="Интероперабельность-с-другими-системами-сборки"><a class="header" href="#Интероперабельность-с-другими-системами-сборки">Интероперабельность с другими системами сборки</a></h2>
<p>Общим требованием для включения Rust в ваш проект для встраиваемых систем является объединение Cargo с вашей существующей системой сборки, такой как make или cmake.</p>
<p>Мы собираем примеры и случаи использования для этого в нашем трекере задач в <a href="https://github.com/rust-embedded/book/issues/61">issue #61</a>.</p>
<h2 id="Интероперабельность-с-rtos"><a class="header" href="#Интероперабельность-с-rtos">Интероперабельность с RTOS</a></h2>
<p>Интеграция Rust с RTOS, такими как FreeRTOS или ChibiOS, все еще находится в стадии разработки; особенно вызов функций RTOS из Rust может быть сложным.</p>
<p>Мы собираем примеры и случаи использования для этого в нашем трекере задач в <a href="https://github.com/rust-embedded/book/issues/62">issue #62</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Немного-c-в-вашем-rust"><a class="header" href="#Немного-c-в-вашем-rust">Немного C в вашем Rust</a></h1>
<p>Использование кода на C или C++ внутри проекта на Rust состоит из двух основных частей:</p>
<ul>
<li>Обертывание открытого API на C для использования в Rust</li>
<li>Сборка кода на C или C++ для интеграции с кодом на Rust</li>
</ul>
<p>Поскольку C++ не имеет стабильного ABI для компилятора Rust, рекомендуется использовать ABI <code>C</code> при комбинировании Rust с C или C++.</p>
<h2 id="Определение-интерфейса"><a class="header" href="#Определение-интерфейса">Определение интерфейса</a></h2>
<p>Перед использованием кода на C или C++ из Rust необходимо определить (на Rust) типы данных и сигнатуры функций, существующие в связанном коде. В C или C++ вы бы подключили заголовочный файл (<code>.h</code> или <code>.hpp</code>), который определяет эти данные. В Rust необходимо либо вручную перевести эти определения в Rust, либо использовать инструмент для их автоматической генерации.</p>
<p>Сначала мы рассмотрим ручной перевод этих определений из C/C++ в Rust.</p>
<h3 id="Обертывание-функций-и-типов-данных-c"><a class="header" href="#Обертывание-функций-и-типов-данных-c">Обертывание функций и типов данных C</a></h3>
<p>Обычно библиотеки, написанные на C или C++, предоставляют заголовочный файл, определяющий все типы и функции, используемые в публичных интерфейсах. Пример такого файла может выглядеть следующим образом:</p>
<pre><code class="language-C">/* File: cool.h */
typedef struct CoolStruct {
    int x;
    int y;
} CoolStruct;

void cool_function(int i, char c, CoolStruct* cs);
</code></pre>
<p>При переводе в Rust этот интерфейс будет выглядеть так:</p>
<pre><code class="language-rust ignore">/* File: cool_bindings.rs */
#[repr(C)]
pub struct CoolStruct {
    pub x: cty::c_int,
    pub y: cty::c_int,
}

extern "C" {
    pub fn cool_function(
        i: cty::c_int,
        c: cty::c_char,
        cs: *mut CoolStruct
    );
}</code></pre>
<p>Разберем это определение по частям, чтобы объяснить каждый компонент.</p>
<pre><code class="language-rust ignore">#[repr(C)]
pub struct CoolStruct { ... }</code></pre>
<p>По умолчанию Rust не гарантирует порядок, выравнивание или размер данных, включенных в <code>struct</code>. Чтобы обеспечить совместимость с кодом на C, мы используем атрибут <code>#[repr(C)]</code>, который указывает компилятору Rust всегда использовать те же правила, что и C, для организации данных внутри структуры.</p>
<pre><code class="language-rust ignore">pub x: cty::c_int,
pub y: cty::c_int,</code></pre>
<p>Из-за гибкости определения <code>int</code> или <code>char</code> в C или C++ рекомендуется использовать типы из модуля <code>cty</code>, такие как <code>c_int</code> и <code>c_char</code>, чтобы обеспечить совместимость с платформой.</p>
<pre><code class="language-rust ignore">extern "C" {
    pub fn cool_function(
        i: cty::c_int,
        c: cty::c_char,
        cs: *mut CoolStruct
    );
}</code></pre>
<p>Блок <code>extern "C"</code> сообщает компилятору Rust, что указанные функции используют ABI C, обеспечивая их совместимость с функциями, определенными в коде на C. Указатель <code>*mut CoolStruct</code> соответствует указателю <code>CoolStruct*</code> в C, позволяя передавать изменяемые структуры между языками.</p>
<h3 id="Автоматизация-с-помощью-bindgen"><a class="header" href="#Автоматизация-с-помощью-bindgen">Автоматизация с помощью <code>bindgen</code></a></h3>
<p>Ручной перевод заголовочных файлов может быть трудоемким и подверженным ошибкам, особенно для больших библиотек. Инструмент <a href="https://github.com/rust-lang/bindgen"><code>bindgen</code></a> автоматизирует этот процесс, генерируя определения Rust из заголовочных файлов C или C++.</p>
<p>Чтобы использовать <code>bindgen</code>, добавьте его в зависимости вашего проекта в <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
bindgen = "0.59"
</code></pre>
<p>Затем создайте скрипт <code>build.rs</code> для генерации привязок:</p>
<pre><code class="language-rust ignore">use bindgen;

fn main() {
    println!("cargo:rerun-if-changed=wrapper.h");

    bindgen::Builder::default()
        .header("wrapper.h")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file("src/bindings.rs")
        .expect("Couldn't write bindings!");
}</code></pre>
<p>Файл <code>wrapper.h</code> должен включать заголовочные файлы C, которые вы хотите преобразовать:</p>
<pre><code class="language-C">/* wrapper.h */
#include "cool.h"
</code></pre>
<p>Запуск <code>cargo build</code> сгенерирует файл <code>src/bindings.rs</code>, содержащий определения Rust для всех типов и функций из <code>cool.h</code>. Используйте их в вашем коде на Rust:</p>
<pre><code class="language-rust ignore">include!(concat!(env!("OUT_DIR"), "/bindings.rs"));</code></pre>
<h2 id="Сборка-кода-на-cc"><a class="header" href="#Сборка-кода-на-cc">Сборка кода на C/C++</a></h2>
<p>После определения интерфейса необходимо скомпилировать код на C или C++ и связать его с вашим проектом на Rust. Это обычно делается с помощью скрипта <code>build.rs</code>.</p>
<h3 id="Скрипты-сборки"><a class="header" href="#Скрипты-сборки">Скрипты сборки</a></h3>
<p>Скрипт <code>build.rs</code> — это файл, написанный на синтаксисе Rust, который выполняется на вашей машине компиляции ПОСЛЕ сборки зависимостей вашего проекта, но ДО сборки самого проекта.</p>
<p>Полное описание можно найти <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">здесь</a>. Скрипты <code>build.rs</code> полезны для генерации кода (например, через [bindgen]), вызова внешних систем сборки, таких как <code>Make</code>, или прямой компиляции C/C++ с использованием крейта <code>cc</code>.</p>
<h3 id="Вызов-внешних-систем-сборки"><a class="header" href="#Вызов-внешних-систем-сборки">Вызов внешних систем сборки</a></h3>
<p>Для проектов с сложными внешними проектами или системами сборки проще всего использовать <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a> для вызова других систем сборки, переходя по относительным путям, вызывая фиксированную команду (например, <code>make library</code>) и затем копируя полученную статическую библиотеку в нужное место в директории сборки <code>target</code>.</p>
<p>Хотя ваш крейт может быть нацелен на платформу <code>no_std</code>, ваш <code>build.rs</code> выполняется только на машинах, компилирующих ваш крейт. Это означает, что вы можете использовать любые крейты Rust, которые работают на вашем хосте компиляции.</p>
<h3 id="Сборка-кода-на-cc-с-помощью-крейта-cc"><a class="header" href="#Сборка-кода-на-cc-с-помощью-крейта-cc">Сборка кода на C/C++ с помощью крейта <code>cc</code></a></h3>
<p>Для проектов с ограниченными зависимостями или сложностью, или для проектов, где трудно модифицировать систему сборки для создания статической библиотеки (вместо финального бинарного файла или исполняемого файла), проще использовать крейт [<code>cc</code>], который предоставляет идиоматичный интерфейс Rust к компилятору, предоставляемому хостом.</p>
<p>В простейшем случае компиляции одного файла C в качестве зависимости для статической библиотеки пример скрипта <code>build.rs</code>, использующего крейт [<code>cc</code>], будет выглядеть так:</p>
<pre><code class="language-rust ignore">fn main() {
    cc::Build::new()
        .file("src/foo.c")
        .compile("foo");
}</code></pre>
<p>Файл <code>build.rs</code> размещается в корне пакета. Затем <code>cargo build</code> скомпилирует и выполнит его перед сборкой пакета. Генерируется статический архив с именем <code>libfoo.a</code>, который помещается в директорию <code>target</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Немного-rust-в-вашем-c"><a class="header" href="#Немного-rust-в-вашем-c">Немного Rust в вашем C</a></h1>
<p>Использование кода на Rust внутри проекта на C или C++ в основном состоит из двух частей:</p>
<ul>
<li>Создание API, совместимого с C, на Rust</li>
<li>Встраивание вашего проекта на Rust во внешнюю систему сборки</li>
</ul>
<p>Помимо <code>cargo</code> и <code>meson</code>, большинство систем сборки не имеют встроенной поддержки Rust. Поэтому, скорее всего, лучше всего использовать <code>cargo</code> для компиляции вашего крейта и любых его зависимостей.</p>
<h2 id="Настройка-проекта"><a class="header" href="#Настройка-проекта">Настройка проекта</a></h2>
<p>Создайте новый проект <code>cargo</code> как обычно.</p>
<p>Есть флаги, чтобы указать <code>cargo</code> генерировать системную библиотеку вместо обычной цели Rust. Это также позволяет задать другое имя выходной библиотеки, если вы хотите, чтобы оно отличалось от остальной части вашего крейта.</p>
<pre><code class="language-toml">[lib]
name = "your_crate"
crate-type = ["cdylib"]      # Создает динамическую библиотеку
# crate-type = ["staticlib"] # Создает статическую библиотеку
</code></pre>
<h2 id="Создание-api-для-c"><a class="header" href="#Создание-api-для-c">Создание API для C</a></h2>
<p>Поскольку C++ не имеет стабильного ABI для компилятора Rust, мы используем <code>C</code> для любой интероперабельности между разными языками. Это не исключение при использовании Rust внутри кода на C и C++.</p>
<h3 id="no_mangle"><a class="header" href="#no_mangle"><code>#[no_mangle]</code></a></h3>
<p>Компилятор Rust искажает имена символов иначе, чем ожидают компоновщики нативного кода. Поэтому любая функция, которую Rust экспортирует для использования вне Rust, должна быть помечена так, чтобы компилятор не искажал ее имя.</p>
<h3 id="extern-c"><a class="header" href="#extern-c"><code>extern "C"</code></a></h3>
<p>По умолчанию любая функция, написанная на Rust, использует ABI Rust (который также не стабилизирован). Вместо этого, при создании внешних API FFI, нам нужно указать компилятору использовать системный ABI.</p>
<p>В зависимости от вашей платформы, вы можете захотеть нацелиться на конкретную версию ABI, которые задокументированы <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">здесь</a>.</p>
<hr />
<p>Собирая эти части вместе, вы получаете функцию, которая выглядит примерно так:</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern "C" fn rust_function() {

}</code></pre>
<p>Как и при использовании кода на <code>C</code> в вашем проекте на Rust, вам теперь нужно преобразовывать данные в форму, понятную остальной части приложения.</p>
<h2 id="Компоновка-и-общий-контекст-проекта"><a class="header" href="#Компоновка-и-общий-контекст-проекта">Компоновка и общий контекст проекта</a></h2>
<p>Итак, одна половина проблемы решена. Как теперь это использовать?</p>
<p><strong>Это очень сильно зависит от вашего проекта и/или системы сборки</strong></p>
<p><code>cargo</code> создаст файл <code>my_lib.so</code>/<code>my_lib.dll</code> или <code>my_lib.a</code> в зависимости от вашей платформы и настроек. Эту библиотеку можно просто слинковать вашей системой сборки.</p>
<p>Однако вызов функции Rust из C требует заголовочного файла для объявления сигнатур функций.</p>
<p>Каждая функция в вашем Rust-FFI API должна иметь соответствующую функцию в заголовочном файле.</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern "C" fn rust_function() {}</code></pre>
<p>будет преобразована в</p>
<pre><code class="language-C">void rust_function();
</code></pre>
<p>и т.д.</p>
<p>Существует инструмент для автоматизации этого процесса, называемый <a href="https://github.com/eqrion/cbindgen">cbindgen</a>, который анализирует ваш код на Rust и генерирует заголовочные файлы для ваших проектов на C и C++.</p>
<p>На этом этапе использование функций Rust из C так же просто, как включение заголовочного файла и их вызов!</p>
<pre><code class="language-C">#include "my-rust-project.h"
rust_function();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Несортированные-темы"><a class="header" href="#Несортированные-темы">Несортированные темы</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Оптимизации-компромисс-между-скоростью-и-размером"><a class="header" href="#Оптимизации-компромисс-между-скоростью-и-размером">Оптимизации: компромисс между скоростью и размером</a></h1>
<p>Каждый хочет, чтобы его программа была очень быстрой и очень компактной, но обычно невозможно достичь обеих характеристик одновременно. В этом разделе обсуждаются различные уровни оптимизации, предоставляемые компилятором <code>rustc</code>, и их влияние на время выполнения и размер бинарного файла программы.</p>
<h2 id="Без-оптимизаций"><a class="header" href="#Без-оптимизаций">Без оптимизаций</a></h2>
<p>Это настройка по умолчанию. Когда вы вызываете <code>cargo build</code>, используется профиль разработки (также известный как <code>dev</code>). Этот профиль оптимизирован для отладки, поэтому он включает отладочную информацию и <em>не</em> включает никаких оптимизаций, т.е. используется <code>-C opt-level = 0</code>.</p>
<p>По крайней мере, для разработки без операционной системы отладочная информация не занимает места во флэш-памяти / ПЗУ, поэтому мы рекомендуем включать отладочную информацию в профиле выпуска — по умолчанию она отключена. Это позволит использовать точки останова при отладке сборок выпуска.</p>
<pre><code class="language-toml">[profile.release]
# символы полезны, и они не увеличивают размер во флэш-памяти
debug = true
</code></pre>
<p>Отсутствие оптимизаций отлично подходит для отладки, поскольку пошаговое выполнение кода ощущается как выполнение программы оператор за оператором, плюс вы можете выводить значения локальных переменных и аргументов функций в GDB. При оптимизированном коде попытка вывести переменные приводит к сообщению <code>$0 = &lt;value optimized out&gt;</code>.</p>
<p>Самый большой недостаток профиля <code>dev</code> заключается в том, что получаемый бинарный файл будет огромным и медленным. Размер обычно представляет большую проблему, поскольку неоптимизированные бинарные файлы могут занимать десятки килобайт флэш-памяти, которой может не быть на вашем целевом устройстве — в результате неоптимизированный бинарный файл просто не помещается в ваше устройство!</p>
<p>Можно ли получить меньшие бинарные файлы, удобные для отладки? Да, есть один прием.</p>
<h3 id="Оптимизация-зависимостей"><a class="header" href="#Оптимизация-зависимостей">Оптимизация зависимостей</a></h3>
<p>Есть функция Cargo под названием <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#overrides"><code>profile-overrides</code></a>, которая позволяет переопределять уровень оптимизации для зависимостей. Вы можете использовать эту функцию, чтобы оптимизировать все зависимости для размера, сохраняя верхний крейт неоптимизированным и удобным для отладки.</p>
<p>Учтите, что обобщенный код может быть проблематичным при использовании различных уровней оптимизации, поэтому вам может потребоваться экспериментировать с настройками.</p>
<h3 id="Оптимизация-для-скорости"><a class="header" href="#Оптимизация-для-скорости">Оптимизация для скорости</a></h3>
<p>Если вы хотите, чтобы ваши бинарные файлы выпуска были оптимизированы для скорости, измените настройку <code>profile.release.opt-level</code> в <code>Cargo.toml</code>, как показано ниже:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 3
</code></pre>
<p>или</p>
<pre><code class="language-toml">[profile.release]
opt-level = 2
</code></pre>
<p>Эти два уровня оптимизации (<code>opt-level = 2</code> и <code>3</code>) значительно увеличивают производительность, но также могут увеличивать размер бинарного файла. Если вы не можете позволить себе увеличение размера, вам следует оптимизировать программу для размера.</p>
<h3 id="Оптимизация-для-размера"><a class="header" href="#Оптимизация-для-размера">Оптимизация для размера</a></h3>
<p>По состоянию на 18.09.2018 <code>rustc</code> поддерживает два уровня оптимизации для размера: <code>opt-level = "s"</code> и <code>"z"</code>. Эти названия унаследованы от clang / LLVM и не слишком описательны, но <code>"z"</code> подразумевает, что он производит бинарные файлы меньшего размера, чем <code>"s"</code>.</p>
<p>Если вы хотите, чтобы ваши бинарные файлы выпуска были оптимизированы для размера, измените настройку <code>profile.release.opt-level</code> в <code>Cargo.toml</code>, как показано ниже:</p>
<pre><code class="language-toml">[profile.release]
# или "z"
opt-level = "s"
</code></pre>
<p>Эти два уровня оптимизации значительно снижают порог встраивания LLVM, метрику, используемую для принятия решения о встраивании функции. Одним из принципов Rust являются абстракции с нулевой стоимостью; эти абстракции часто используют множество новых типов и небольших функций для сохранения инвариантов (например, функции, которые заимствуют внутреннее значение, такие как <code>deref</code>, <code>as_ref</code>), поэтому низкий порог встраивания может привести к тому, что LLVM упустит возможности оптимизации (например, устранение мертвых ветвей, встраивание вызовов замыканий).</p>
<p>При оптимизации для размера вы можете попробовать увеличить порог встраивания, чтобы проверить, влияет ли это на размер бинарного файла. Рекомендуемый способ изменения порога встраивания — добавить флаг <code>-C inline-threshold</code> к другим флагам rustflags в <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml"># .cargo/config.toml
# предполагается, что используется шаблон cortex-m-quickstart
[target.'cfg(all(target_arch = "arm", target_os = "none"))']
rustflags = [
  # ..
  "-C", "inline-threshold=123", # +
]
</code></pre>
<p>Какое значение использовать? <a href="https://github.com/rust-lang/rust/blob/1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122">По состоянию на версию 1.29.0 следующие пороги встраивания используются для разных уровней оптимизации</a>:</p>
<ul>
<li><code>opt-level = 3</code> использует 275</li>
<li><code>opt-level = 2</code> использует 225</li>
<li><code>opt-level = "s"</code> использует 75</li>
<li><code>opt-level = "z"</code> использует 25</li>
</ul>
<p>При оптимизации для размера стоит попробовать значения <code>225</code> и <code>275</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Выполнение-математических-операций-с-no_std"><a class="header" href="#Выполнение-математических-операций-с-no_std">Выполнение математических операций с <code>#[no_std]</code></a></h1>
<p>Если вы хотите выполнять математические операции, такие как вычисление квадратного корня или экспоненты числа, и у вас доступна полная стандартная библиотека, ваш код может выглядеть следующим образом:</p>
<pre><code class="language-rs">//! Некоторые математические функции с доступной стандартной библиотекой

fn main() {
    let float: f32 = 4.82832;
    let floored_float = float.floor();

    let sqrt_of_four = floored_float.sqrt();

    let sinus_of_four = floored_float.sin();

    let exponential_of_four = floored_float.exp();
    println!("Округлено вниз тестовое число {} до {}", float, floored_float);
    println!("Квадратный корень из {} равен {}", floored_float, sqrt_of_four);
    println!("Синус числа четыре равен {}", sinus_of_four);
    println!(
        "Экспонента числа четыре с основанием e равна {}",
        exponential_of_four
    )
}
</code></pre>
<p>Без поддержки стандартной библиотеки эти функции недоступны. Вместо этого можно использовать внешний крейт, например <a href="https://crates.io/crates/libm"><code>libm</code></a>. Пример кода в этом случае будет выглядеть так:</p>
<pre><code class="language-rs">#![no_main]
#![no_std]

use panic_halt as _;

use cortex_m_rt::entry;
use cortex_m_semihosting::{debug, hprintln};
use libm::{exp, floorf, sin, sqrtf};

#[entry]
fn main() -&gt; ! {
    let float = 4.82832;
    let floored_float = floorf(float);

    let sqrt_of_four = sqrtf(floored_float);

    let sinus_of_four = sin(floored_float.into());

    let exponential_of_four = exp(floored_float.into());
    hprintln!("Округлено вниз тестовое число {} до {}", float, floored_float).unwrap();
    hprintln!("Квадратный корень из {} равен {}", floored_float, sqrt_of_four).unwrap();
    hprintln!("Синус числа четыре равен {}", sinus_of_four).unwrap();
    hprintln!(
        "Экспонента числа четыре с основанием e равна {}",
        exponential_of_four
    )
    .unwrap();
    // Выход из QEMU
    // ПРИМЕЧАНИЕ: не запускайте это на оборудовании; это может повредить состояние OpenOCD
    // debug::exit(debug::EXIT_SUCCESS);

    loop {}
}
</code></pre>
<p>Если вам нужно выполнять более сложные операции, такие как обработка сигналов DSP или продвинутая линейная алгебра на вашем микроконтроллере, следующие крейты могут быть полезны:</p>
<ul>
<li><a href="https://github.com/jacobrosenthal/cmsis-dsp-sys">Привязка к библиотеке CMSIS DSP</a></li>
<li><a href="https://crates.io/crates/constgebra"><code>constgebra</code></a></li>
<li><a href="https://github.com/tarcieri/micromath"><code>micromath</code></a></li>
<li><a href="https://crates.io/crates/microfft"><code>microfft</code></a></li>
<li><a href="https://github.com/dimforge/nalgebra"><code>nalgebra</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Приложение-a-Глоссарий"><a class="header" href="#Приложение-a-Глоссарий">Приложение A: Глоссарий</a></h1>
<p>Экосистема встраиваемых систем полна различных протоколов, аппаратных компонентов и специфичных для производителей терминов и аббревиатур. Этот глоссарий стремится перечислить их с указателями для лучшего понимания.</p>
<h3 id="bsp"><a class="header" href="#bsp">BSP</a></h3>
<p>Крейт поддержки платы (Board Support Crate) предоставляет высокоуровневый интерфейс, настроенный для конкретной платы. Обычно он зависит от крейта <a href="appendix/glossary.html#hal">HAL</a>.
Более подробное описание можно найти на <a href="appendix/../start/registers.html">странице о регистрах с отображением в память</a>
или для более общего обзора смотрите <a href="https://youtu.be/vLYit_HHPaY">это видео</a>.</p>
<h3 id="fpu"><a class="header" href="#fpu">FPU</a></h3>
<p>Блок операций с плавающей запятой (Floating-point Unit). "Математический процессор", выполняющий операции только с числами с плавающей запятой.</p>
<h3 id="hal"><a class="header" href="#hal">HAL</a></h3>
<p>Крейт уровня абстракции аппаратного обеспечения (Hardware Abstraction Layer) предоставляет удобный для разработчика интерфейс к функциям и периферийным устройствам микроконтроллера. Обычно он реализуется поверх крейта <a href="appendix/glossary.html#pac">Peripheral Access Crate (PAC)</a>.
Также он может реализовывать трейты из крейта <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a>.
Более подробное описание можно найти на <a href="appendix/../start/registers.html">странице о регистрах с отображением в память</a>
или для более общего обзора смотрите <a href="https://youtu.be/vLYit_HHPaY">это видео</a>.</p>
<h3 id="i2c"><a class="header" href="#i2c">I2C</a></h3>
<p>Иногда обозначается как <code>I²C</code> или Inter-IC. Это протокол, предназначенный для коммуникации между аппаратными компонентами внутри одной интегральной схемы. Подробности смотрите <a href="https://en.wikipedia.org/wiki/I2c">здесь</a>.</p>
<h3 id="pac"><a class="header" href="#pac">PAC</a></h3>
<p>Крейт доступа к периферийным устройствам (Peripheral Access Crate) предоставляет доступ к периферийным устройствам микроконтроллера. Это один из низкоуровневых крейтов, который обычно генерируется непосредственно из предоставленного <a href="appendix/glossary.html#svd">SVD</a>, часто с использованием <a href="https://github.com/rust-embedded/svd2rust/">svd2rust</a>. Крейт <a href="appendix/glossary.html#hal">уровня абстракции аппаратного обеспечения</a> обычно зависит от этого крейта.
Более подробное описание можно найти на <a href="appendix/../start/registers.html">странице о регистрах с отображением в память</a>
или для более общего обзора смотрите <a href="https://youtu.be/vLYit_HHPaY">это видео</a>.</p>
<h3 id="spi"><a class="header" href="#spi">SPI</a></h3>
<p>Интерфейс периферийных устройств (Serial Peripheral Interface). Подробности смотрите <a href="https://en.wikipedia.org/wiki/Serial_peripheral_interface">здесь</a>.</p>
<h3 id="svd"><a class="header" href="#svd">SVD</a></h3>
<p>Описание системного вида (System View Description) — это формат XML-файла, используемый для описания представления микроконтроллера с точки зрения программиста. Подробности можно прочитать на
<a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">сайте документации ARM CMSIS</a>.</p>
<h3 id="uart"><a class="header" href="#uart">UART</a></h3>
<p>Универсальный асинхронный приёмопередатчик (Universal Asynchronous Receiver-Transmitter). Подробности смотрите <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">здесь</a>.</p>
<h3 id="usart"><a class="header" href="#usart">USART</a></h3>
<p>Универсальный синхронный и асинхронный приёмопередатчик (Universal Synchronous and Asynchronous Receiver-Transmitter). Подробности смотрите <a href="https://en.wikipedia.org/wiki/Universal_synchronous_and_asynchronous_receiver-transmitter">здесь</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
