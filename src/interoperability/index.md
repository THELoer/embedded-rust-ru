# Интероперабельность

Интероперабельность между кодом на Rust и C всегда зависит от преобразования данных между двумя языками. Для этой цели в `stdlib` есть специальный модуль, называемый [`std::ffi`](https://doc.rust-lang.org/std/ffi/index.html).

`std::ffi` предоставляет определения типов для примитивов C, таких как `char`, `int` и `long`. Также он предоставляет утилиты для преобразования более сложных типов, таких как строки, отображая как `&str`, так и `String` на типы C, которые легче и безопаснее обрабатывать.

Начиная с Rust 1.30, функциональность `std::ffi` доступна либо в `core::ffi`, либо в `alloc::ffi`, в зависимости от того, связано ли это с выделением памяти. Крейты [`cty`] и [`cstr_core`] также предлагают аналогичные функциональности.

[`cstr_core`]: https://crates.io/crates/cstr_core
[`cty`]: https://crates.io/crates/cty

| Тип Rust       | Промежуточный | Тип C          |
|----------------|---------------|----------------|
| `String`       | `CString`     | `char *`       |
| `&str`         | `CStr`        | `const char *` |
| `()`           | `c_void`      | `void`         |
| `u32` или `u64`| `c_uint`      | `unsigned int` |
| и т.д.         | ...           | ...            |

Значение типа-примитива C можно использовать как соответствующий тип Rust и наоборот, поскольку первый является просто псевдонимом второго. Например, следующий код компилируется на платформах, где `unsigned int` имеет длину 32 бита:

```rust,ignore
fn foo(num: u32) {
    let c_num: c_uint = num;
    let r_num: u32 = c_num;
}
```

## Интероперабельность с другими системами сборки

Общим требованием для включения Rust в ваш проект для встраиваемых систем является объединение Cargo с вашей существующей системой сборки, такой как make или cmake.

Мы собираем примеры и случаи использования для этого в нашем трекере задач в [issue #61].

[issue #61]: https://github.com/rust-embedded/book/issues/61

## Интероперабельность с RTOS

Интеграция Rust с RTOS, такими как FreeRTOS или ChibiOS, все еще находится в стадии разработки; особенно вызов функций RTOS из Rust может быть сложным.

Мы собираем примеры и случаи использования для этого в нашем трекере задач в [issue #62].

[issue #62]: https://github.com/rust-embedded/book/issues/62
